(()=>{"use strict";var e,t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};t.r(r),t.d(r,{Lifecycle:()=>n,autoInjectable:()=>C,container:()=>b,delay:()=>p,inject:()=>M,injectAll:()=>j,injectAllWithTransform:()=>x,injectWithTransform:()=>E,injectable:()=>T,instanceCachingFactory:()=>I,instancePerContainerCachingFactory:()=>N,isClassProvider:()=>g,isFactoryProvider:()=>u,isNormalToken:()=>f,isTokenProvider:()=>c,isValueProvider:()=>l,predicateAwareClassFactory:()=>$,registry:()=>_,scoped:()=>D,singleton:()=>O}),function(e){e[e.Transient=0]="Transient",e[e.Singleton=1]="Singleton",e[e.ResolutionScoped=2]="ResolutionScoped",e[e.ContainerScoped=3]="ContainerScoped"}(e||(e={}));const n=e,s="injectionTokens";function o(e){const t=Reflect.getMetadata("design:paramtypes",e)||[],r=Reflect.getOwnMetadata(s,e)||{};return Object.keys(r).forEach((e=>{t[+e]=r[e]})),t}function i(e,t){return function(r,n,o){const i=Reflect.getOwnMetadata(s,r)||{};i[o]=t?{token:e,transform:t.transformToken,transformArgs:t.args||[]}:e,Reflect.defineMetadata(s,i,r)}}function c(e){return!!e.useToken}function l(e){return null!=e.useValue}function u(e){return!!e.useFactory}class a{constructor(e){this.wrap=e,this.reflectMethods=["get","getPrototypeOf","setPrototypeOf","getOwnPropertyDescriptor","defineProperty","has","set","deleteProperty","apply","construct","ownKeys"]}createProxy(e){let t,r=!1;return new Proxy({},this.createHandler((()=>(r||(t=e(this.wrap()),r=!0),t))))}createHandler(e){const t={};return this.reflectMethods.forEach((r=>{t[r]=(...t)=>(t[0]=e(),(0,Reflect[r])(...t))})),t}}function p(e){if(void 0===e)throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");return new a(e)}function f(e){return"string"==typeof e||"symbol"==typeof e}function h(e){return"object"==typeof e&&"token"in e&&"multiple"in e}function d(e){return"object"==typeof e&&"token"in e&&"transform"in e}function g(e){return!!e.useClass}class y{constructor(){this._registryMap=new Map}entries(){return this._registryMap.entries()}getAll(e){return this.ensure(e),this._registryMap.get(e)}get(e){this.ensure(e);const t=this._registryMap.get(e);return t[t.length-1]||null}set(e,t){this.ensure(e),this._registryMap.get(e).push(t)}setAll(e,t){this._registryMap.set(e,t)}has(e){return this.ensure(e),this._registryMap.get(e).length>0}clear(){this._registryMap.clear()}ensure(e){this._registryMap.has(e)||this._registryMap.set(e,[])}}class v extends y{}class m{constructor(){this.scopedResolutions=new Map}}function w(e,t,r){const[,n=null]=e.toString().match(/constructor\(([\w, ]+)\)/)||[],s=function(e,t){return null===e?`at position #${t}`:`"${e.split(",")[t].trim()}" at position #${t}`}(n,t);return function(e,t,r="    "){return[e,...t.message.split("\n").map((e=>r+e))].join("\n")}(`Cannot inject the dependency ${s} of "${e.name}" constructor. Reason:`,r)}class R extends y{}class k extends y{}class A{constructor(){this.preResolution=new R,this.postResolution=new k}}const P=new Map;class S{constructor(e){this.parent=e,this._registry=new v,this.interceptors=new A,this.disposed=!1,this.disposables=new Set}register(e,t,r={lifecycle:n.Transient}){let s;if(this.ensureNotDisposed(),s=function(e){return g(e)||l(e)||c(e)||u(e)}(t)?t:{useClass:t},c(s)){const t=[e];let r=s;for(;null!=r;){const e=r.useToken;if(t.includes(e))throw new Error(`Token registration cycle detected! ${[...t,e].join(" -> ")}`);t.push(e);const n=this._registry.get(e);r=n&&c(n.provider)?n.provider:null}}if((r.lifecycle===n.Singleton||r.lifecycle==n.ContainerScoped||r.lifecycle==n.ResolutionScoped)&&(l(s)||u(s)))throw new Error(`Cannot use lifecycle "${n[r.lifecycle]}" with ValueProviders or FactoryProviders`);return this._registry.set(e,{provider:s,options:r}),this}registerType(e,t){return this.ensureNotDisposed(),f(t)?this.register(e,{useToken:t}):this.register(e,{useClass:t})}registerInstance(e,t){return this.ensureNotDisposed(),this.register(e,{useValue:t})}registerSingleton(e,t){if(this.ensureNotDisposed(),f(e)){if(f(t))return this.register(e,{useToken:t},{lifecycle:n.Singleton});if(t)return this.register(e,{useClass:t},{lifecycle:n.Singleton});throw new Error('Cannot register a type name as a singleton without a "to" token')}let r=e;return t&&!f(t)&&(r=t),this.register(e,{useClass:r},{lifecycle:n.Singleton})}resolve(e,t=new m){this.ensureNotDisposed();const r=this.getRegistration(e);if(!r&&f(e))throw new Error(`Attempted to resolve unregistered dependency token: "${e.toString()}"`);if(this.executePreResolutionInterceptor(e,"Single"),r){const n=this.resolveRegistration(r,t);return this.executePostResolutionInterceptor(e,n,"Single"),n}if(function(e){return"function"==typeof e||e instanceof a}(e)){const r=this.construct(e,t);return this.executePostResolutionInterceptor(e,r,"Single"),r}throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.")}executePreResolutionInterceptor(e,t){if(this.interceptors.preResolution.has(e)){const r=[];for(const n of this.interceptors.preResolution.getAll(e))"Once"!=n.options.frequency&&r.push(n),n.callback(e,t);this.interceptors.preResolution.setAll(e,r)}}executePostResolutionInterceptor(e,t,r){if(this.interceptors.postResolution.has(e)){const n=[];for(const s of this.interceptors.postResolution.getAll(e))"Once"!=s.options.frequency&&n.push(s),s.callback(e,t,r);this.interceptors.postResolution.setAll(e,n)}}resolveRegistration(e,t){if(this.ensureNotDisposed(),e.options.lifecycle===n.ResolutionScoped&&t.scopedResolutions.has(e))return t.scopedResolutions.get(e);const r=e.options.lifecycle===n.Singleton,s=e.options.lifecycle===n.ContainerScoped,o=r||s;let i;return i=l(e.provider)?e.provider.useValue:c(e.provider)?o?e.instance||(e.instance=this.resolve(e.provider.useToken,t)):this.resolve(e.provider.useToken,t):g(e.provider)?o?e.instance||(e.instance=this.construct(e.provider.useClass,t)):this.construct(e.provider.useClass,t):u(e.provider)?e.provider.useFactory(this):this.construct(e.provider,t),e.options.lifecycle===n.ResolutionScoped&&t.scopedResolutions.set(e,i),i}resolveAll(e,t=new m){this.ensureNotDisposed();const r=this.getAllRegistrations(e);if(!r&&f(e))throw new Error(`Attempted to resolve unregistered dependency token: "${e.toString()}"`);if(this.executePreResolutionInterceptor(e,"All"),r){const n=r.map((e=>this.resolveRegistration(e,t)));return this.executePostResolutionInterceptor(e,n,"All"),n}const n=[this.construct(e,t)];return this.executePostResolutionInterceptor(e,n,"All"),n}isRegistered(e,t=!1){return this.ensureNotDisposed(),this._registry.has(e)||t&&(this.parent||!1)&&this.parent.isRegistered(e,!0)}reset(){this.ensureNotDisposed(),this._registry.clear(),this.interceptors.preResolution.clear(),this.interceptors.postResolution.clear()}clearInstances(){this.ensureNotDisposed();for(const[e,t]of this._registry.entries())this._registry.setAll(e,t.filter((e=>!l(e.provider))).map((e=>(e.instance=void 0,e))))}createChildContainer(){this.ensureNotDisposed();const e=new S(this);for(const[t,r]of this._registry.entries())r.some((({options:e})=>e.lifecycle===n.ContainerScoped))&&e._registry.setAll(t,r.map((e=>e.options.lifecycle===n.ContainerScoped?{provider:e.provider,options:e.options}:e)));return e}beforeResolution(e,t,r={frequency:"Always"}){this.interceptors.preResolution.set(e,{callback:t,options:r})}afterResolution(e,t,r={frequency:"Always"}){this.interceptors.postResolution.set(e,{callback:t,options:r})}dispose(){return e=this,t=void 0,n=function*(){this.disposed=!0;const e=[];this.disposables.forEach((t=>{const r=t.dispose();r&&e.push(r)})),yield Promise.all(e)},new((r=void 0)||(r=Promise))((function(s,o){function i(e){try{l(n.next(e))}catch(e){o(e)}}function c(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,c)}l((n=n.apply(e,t||[])).next())}));var e,t,r,n}getRegistration(e){return this.isRegistered(e)?this._registry.get(e):this.parent?this.parent.getRegistration(e):null}getAllRegistrations(e){return this.isRegistered(e)?this._registry.getAll(e):this.parent?this.parent.getAllRegistrations(e):null}construct(e,t){if(e instanceof a)return e.createProxy((e=>this.resolve(e,t)));const r=(()=>{const r=P.get(e);if(!r||0===r.length){if(0===e.length)return new e;throw new Error(`TypeInfo not known for "${e.name}"`)}const n=r.map(this.resolveParams(t,e));return new e(...n)})();var n;return"function"!=typeof(n=r).dispose||n.dispose.length>0||this.disposables.add(r),r}resolveParams(e,t){return(r,n)=>{try{return h(r)?d(r)?r.multiple?this.resolve(r.transform).transform(this.resolveAll(r.token),...r.transformArgs):this.resolve(r.transform).transform(this.resolve(r.token,e),...r.transformArgs):r.multiple?this.resolveAll(r.token):this.resolve(r.token,e):d(r)?this.resolve(r.transform,e).transform(this.resolve(r.token,e),...r.transformArgs):this.resolve(r,e)}catch(e){throw new Error(w(t,n,e))}}}ensureNotDisposed(){if(this.disposed)throw new Error("This container has been disposed, you cannot interact with a disposed container")}}const b=new S,C=function(){return function(e){const t=o(e);return class extends e{constructor(...r){super(...r.concat(t.slice(r.length).map(((t,n)=>{try{return h(t)?d(t)?t.multiple?b.resolve(t.transform).transform(b.resolveAll(t.token),...t.transformArgs):b.resolve(t.transform).transform(b.resolve(t.token),...t.transformArgs):t.multiple?b.resolveAll(t.token):b.resolve(t.token):d(t)?b.resolve(t.transform).transform(b.resolve(t.token),...t.transformArgs):b.resolve(t)}catch(t){const s=n+r.length;throw new Error(w(e,s,t))}}))))}}}},M=function(e){return i(e)},T=function(){return function(e){P.set(e,o(e))}},_=function(e=[]){return function(t){return e.forEach((e=>{var{token:t,options:r}=e,n=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(e);s<n.length;s++)t.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(e,n[s])&&(r[n[s]]=e[n[s]])}return r}(e,["token","options"]);return b.register(t,n,r)})),t}},O=function(){return function(e){T()(e),b.registerSingleton(e)}},j=function(e){return i({token:e,multiple:!0})},x=function(e,t,...r){return i({token:e,multiple:!0,transform:t,transformArgs:r})},E=function(e,t,...r){return i(e,{transformToken:t,args:r})};function D(e,t){return function(r){T()(r),b.register(t||r,r,{lifecycle:e})}}function I(e){let t;return r=>(null==t&&(t=e(r)),t)}function N(e){const t=new WeakMap;return r=>{let n=t.get(r);return null==n&&(n=e(r),t.set(r,n)),n}}function $(e,t,r,n=!0){let s,o;return i=>{const c=e(i);return n&&o===c||(s=(o=c)?i.resolve(t):i.resolve(r)),s}}if("undefined"==typeof Reflect||!Reflect.getMetadata)throw new Error("tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point.");module.exports=r})();
//# sourceMappingURL=https://raw.githubusercontent.com/mskg/homey-heating/release/v2.0.0-rc15/node_modules/tsyringe/index.js.map