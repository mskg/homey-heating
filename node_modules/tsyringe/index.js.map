{"version":3,"file":"node_modules/tsyringe/index.js","mappings":"mBACA,ICDIA,EDCAC,EAAsB,CEA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,4bHJ9D,SAAWjB,GACPA,EAAUA,EAAqB,UAAI,GAAK,YACxCA,EAAUA,EAAqB,UAAI,GAAK,YACxCA,EAAUA,EAA4B,iBAAI,GAAK,mBAC/CA,EAAUA,EAA2B,gBAAI,GAAK,iBACjD,CALD,CAKGA,IAAcA,EAAY,CAAC,IAC9B,UIPakB,EAA+B,kBACrC,SAASC,EAAaC,GACzB,MAAMC,EAASC,QAAQC,YAAY,oBAAqBH,IAAW,GAC7DI,EAAkBF,QAAQG,eAAeP,EAA8BE,IAAW,CAAC,EAIzF,OAHAd,OAAOoB,KAAKF,GAAiBG,SAAQvB,IACjCiB,GAAQjB,GAAOoB,EAAgBpB,EAAI,IAEhCiB,CACX,CACO,SAASO,EAA6BC,EAAMC,GAC/C,OAAO,SAAUV,EAAQW,EAAcC,GACnC,MAAMC,EAAcX,QAAQG,eAAeP,EAA8BE,IAAW,CAAC,EACrFa,EAAYD,GAAkBF,EACxB,CACEI,MAAOL,EACPC,UAAWA,EAAUK,eACrBC,cAAeN,EAAUO,MAAQ,IAEnCR,EACNP,QAAQgB,eAAepB,EAA8Be,EAAab,EACtE,CACJ,CCrBO,SAASmB,EAAgBC,GAC5B,QAASA,EAASC,QACtB,CCFO,SAASC,EAAgBF,GAC5B,OAA4BG,MAArBH,EAASI,QACpB,CCFO,SAASC,EAAkBL,GAC9B,QAASA,EAASM,UACtB,CCFO,MAAMC,EACTC,YAAYC,GACRC,KAAKD,KAAOA,EACZC,KAAKC,eAAiB,CAClB,MACA,iBACA,iBACA,2BACA,iBACA,MACA,MACA,iBACA,QACA,YACA,UAER,CACAC,YAAYC,GAER,IACIpC,EADAqC,GAAO,EASX,OAAO,IAAIC,MAVI,CAAC,EAUSL,KAAKM,eAPR,KACbF,IACDrC,EAAQoC,EAAaH,KAAKD,QAC1BK,GAAO,GAEJrC,KAGf,CACAuC,cAAcC,GACV,MAAMC,EAAU,CAAC,EASjB,OADAR,KAAKC,eAAexB,SAPHgC,IACbD,EAAQC,GAAQ,IAAItB,KAChBA,EAAK,GAAKoB,KAEHG,EADQtC,QAAQqC,OACNtB,GACpB,IAGEqB,CACX,EAEG,SAASG,EAAMC,GAClB,QAAkC,IAAvBA,EACP,MAAM,IAAIC,MAAM,2EAEpB,OAAO,IAAIhB,EAAmBe,EAClC,CC/CO,SAASE,EAAc9B,GAC1B,MAAwB,iBAAVA,GAAuC,iBAAVA,CAC/C,CACO,SAAS+B,EAAkBC,GAC9B,MAA8B,iBAAfA,GACX,UAAWA,GACX,aAAcA,CACtB,CACO,SAASC,EAAsBD,GAClC,MAA8B,iBAAfA,GACX,UAAWA,GACX,cAAeA,CACvB,CCbO,SAASE,EAAgB5B,GAC5B,QAASA,EAAS6B,QACtB,CCFe,MAAMC,EACjBtB,cACIE,KAAKqB,aAAe,IAAIC,GAC5B,CACAC,UACI,OAAOvB,KAAKqB,aAAaE,SAC7B,CACAC,OAAOtE,GAEH,OADA8C,KAAKyB,OAAOvE,GACL8C,KAAKqB,aAAa9D,IAAIL,EACjC,CACAK,IAAIL,GACA8C,KAAKyB,OAAOvE,GACZ,MAAMa,EAAQiC,KAAKqB,aAAa9D,IAAIL,GACpC,OAAOa,EAAMA,EAAM2D,OAAS,IAAM,IACtC,CACAC,IAAIzE,EAAKa,GACLiC,KAAKyB,OAAOvE,GACZ8C,KAAKqB,aAAa9D,IAAIL,GAAK0E,KAAK7D,EACpC,CACA8D,OAAO3E,EAAKa,GACRiC,KAAKqB,aAAaM,IAAIzE,EAAKa,EAC/B,CACA+D,IAAI5E,GAEA,OADA8C,KAAKyB,OAAOvE,GACL8C,KAAKqB,aAAa9D,IAAIL,GAAKwE,OAAS,CAC/C,CACAK,QACI/B,KAAKqB,aAAaU,OACtB,CACAN,OAAOvE,GACE8C,KAAKqB,aAAaS,IAAI5E,IACvB8C,KAAKqB,aAAaM,IAAIzE,EAAK,GAEnC,ECjCW,MAAM8E,UAAiBZ,GCDvB,MAAMa,EACjBnC,cACIE,KAAKkC,kBAAoB,IAAIZ,GACjC,ECOG,SAASa,EAAgBC,EAAMC,EAAUC,GAC5C,MAAO,CAAEnE,EAAS,MAAQiE,EAAKG,WAAWC,MAAM,6BAA+B,GACzEC,EAZV,SAA0BtE,EAAQuE,GAC9B,OAAe,OAAXvE,EACO,gBAAgBuE,IAGpB,IADSvE,EAAOwE,MAAM,KAAKD,GAAKE,wBACHF,GACxC,CAMgBG,CAAiB1E,EAAQkE,GACrC,OANJ,SAA6BS,EAAKC,EAAGC,EAAS,QAC1C,MAAO,CAACF,KAAQC,EAAEE,QAAQN,MAAM,MAAMO,KAAIC,GAAKH,EAASG,KAAIC,KAAK,KACrE,CAIWC,CAAoB,gCAAgCZ,SAAWL,EAAK3B,6BAA8B6B,EAC7G,CCbO,MAAMgB,UAAkClC,GAExC,MAAMmC,UAAmCnC,GAEjC,MAAMoC,EACjB1D,cACIE,KAAKyD,cAAgB,IAAIH,EACzBtD,KAAK0D,eAAiB,IAAIH,CAC9B,ECEG,MAAMI,EAAW,IAAIrC,IAC5B,MAAMsC,EACF9D,YAAY+D,GACR7D,KAAK6D,OAASA,EACd7D,KAAK8D,UAAY,IAAI9B,EACrBhC,KAAK+D,aAAe,IAAIP,EACxBxD,KAAKgE,UAAW,EAChBhE,KAAKiE,YAAc,IAAIC,GAC3B,CACAC,SAASnF,EAAOoF,EAAuBC,EAAU,CAAEC,UAAW,cAE1D,IAAIhF,EAOJ,GARAU,KAAKuE,oBAGDjF,ECpBL,SAAoBA,GACvB,OAAQ4B,EAAgB5B,IACpBE,EAAgBF,IAChBD,EAAgBC,IAChBK,EAAkBL,EAC1B,CDcakF,CAAWJ,GAIDA,EAHA,CAAEjD,SAAUiD,GAKvB/E,EAAgBC,GAAW,CAC3B,MAAMmF,EAAO,CAACzF,GACd,IAAI0F,EAAgBpF,EACpB,KAAwB,MAAjBoF,GAAuB,CAC1B,MAAMC,EAAeD,EAAcnF,SACnC,GAAIkF,EAAKG,SAASD,GACd,MAAM,IAAI9D,MAAM,sCAAsC,IAAI4D,EAAME,GAAcvB,KAAK,WAEvFqB,EAAK7C,KAAK+C,GACV,MAAME,EAAe7E,KAAK8D,UAAUvG,IAAIoH,GAEpCD,EADAG,GAAgBxF,EAAgBwF,EAAavF,UAC7BuF,EAAavF,SAGb,IAExB,CACJ,CACA,IAAI+E,EAAQC,YAAc,aACtBD,EAAQC,WAAa,mBACrBD,EAAQC,WAAa,sBACjB9E,EAAgBF,IAAaK,EAAkBL,IAC/C,MAAM,IAAIuB,MAAM,yBAAyB,EAAUwD,EAAQC,uDAInE,OADAtE,KAAK8D,UAAUnC,IAAI3C,EAAO,CAAEM,WAAU+E,YAC/BrE,IACX,CACA8E,aAAaC,EAAMC,GAEf,OADAhF,KAAKuE,oBACDzD,EAAckE,GACPhF,KAAKmE,SAASY,EAAM,CACvBxF,SAAUyF,IAGXhF,KAAKmE,SAASY,EAAM,CACvB5D,SAAU6D,GAElB,CACAC,iBAAiBjG,EAAOkG,GAEpB,OADAlF,KAAKuE,oBACEvE,KAAKmE,SAASnF,EAAO,CACxBU,SAAUwF,GAElB,CACAC,kBAAkBJ,EAAMC,GAEpB,GADAhF,KAAKuE,oBACDzD,EAAciE,GAAO,CACrB,GAAIjE,EAAckE,GACd,OAAOhF,KAAKmE,SAASY,EAAM,CACvBxF,SAAUyF,GACX,CAAEV,UAAW,cAEf,GAAIU,EACL,OAAOhF,KAAKmE,SAASY,EAAM,CACvB5D,SAAU6D,GACX,CAAEV,UAAW,cAEpB,MAAM,IAAIzD,MAAM,kEACpB,CACA,IAAIM,EAAW4D,EAIf,OAHIC,IAAOlE,EAAckE,KACrB7D,EAAW6D,GAERhF,KAAKmE,SAASY,EAAM,CACvB5D,YACD,CAAEmD,UAAW,aACpB,CACAc,QAAQpG,EAAOqG,EAAU,IAAIpD,GACzBjC,KAAKuE,oBACL,MAAMM,EAAe7E,KAAKsF,gBAAgBtG,GAC1C,IAAK6F,GAAgB/D,EAAc9B,GAC/B,MAAM,IAAI6B,MAAM,wDAAwD7B,EAAMuD,eAGlF,GADAvC,KAAKuF,gCAAgCvG,EAAO,UACxC6F,EAAc,CACd,MAAMW,EAASxF,KAAKyF,oBAAoBZ,EAAcQ,GAEtD,OADArF,KAAK0F,iCAAiC1G,EAAOwG,EAAQ,UAC9CA,CACX,CACA,GP/FD,SAA4BxG,GAC/B,MAAwB,mBAAVA,GAAwBA,aAAiBa,CAC3D,CO6FY8F,CAAmB3G,GAAQ,CAC3B,MAAMwG,EAASxF,KAAK4F,UAAU5G,EAAOqG,GAErC,OADArF,KAAK0F,iCAAiC1G,EAAOwG,EAAQ,UAC9CA,CACX,CACA,MAAM,IAAI3E,MAAM,yHACpB,CACA0E,gCAAgCvG,EAAO6G,GACnC,GAAI7F,KAAK+D,aAAaN,cAAc3B,IAAI9C,GAAQ,CAC5C,MAAM8G,EAAwB,GAC9B,IAAK,MAAMC,KAAe/F,KAAK+D,aAAaN,cAAcjC,OAAOxC,GACxB,QAAjC+G,EAAY1B,QAAQ2B,WACpBF,EAAsBlE,KAAKmE,GAE/BA,EAAYE,SAASjH,EAAO6G,GAEhC7F,KAAK+D,aAAaN,cAAc5B,OAAO7C,EAAO8G,EAClD,CACJ,CACAJ,iCAAiC1G,EAAOwG,EAAQK,GAC5C,GAAI7F,KAAK+D,aAAaL,eAAe5B,IAAI9C,GAAQ,CAC7C,MAAM8G,EAAwB,GAC9B,IAAK,MAAMC,KAAe/F,KAAK+D,aAAaL,eAAelC,OAAOxC,GACzB,QAAjC+G,EAAY1B,QAAQ2B,WACpBF,EAAsBlE,KAAKmE,GAE/BA,EAAYE,SAASjH,EAAOwG,EAAQK,GAExC7F,KAAK+D,aAAaL,eAAe7B,OAAO7C,EAAO8G,EACnD,CACJ,CACAL,oBAAoBZ,EAAcQ,GAE9B,GADArF,KAAKuE,oBACDM,EAAaR,QAAQC,YAAc,oBACnCe,EAAQnD,kBAAkBJ,IAAI+C,GAC9B,OAAOQ,EAAQnD,kBAAkB3E,IAAIsH,GAEzC,MAAMqB,EAAcrB,EAAaR,QAAQC,YAAc,YACjD6B,EAAoBtB,EAAaR,QAAQC,YAAc,kBACvD8B,EAAiBF,GAAeC,EACtC,IAAIE,EAyBJ,OAvBIA,EADA7G,EAAgBqF,EAAavF,UAClBuF,EAAavF,SAASI,SAE5BL,EAAgBwF,EAAavF,UACvB8G,EACLvB,EAAaK,WACVL,EAAaK,SAAWlF,KAAKoF,QAAQP,EAAavF,SAASC,SAAU8F,IACxErF,KAAKoF,QAAQP,EAAavF,SAASC,SAAU8F,GAE9CnE,EAAgB2D,EAAavF,UACvB8G,EACLvB,EAAaK,WACVL,EAAaK,SAAWlF,KAAK4F,UAAUf,EAAavF,SAAS6B,SAAUkE,IAC1ErF,KAAK4F,UAAUf,EAAavF,SAAS6B,SAAUkE,GAEhD1F,EAAkBkF,EAAavF,UACzBuF,EAAavF,SAASM,WAAWI,MAGjCA,KAAK4F,UAAUf,EAAavF,SAAU+F,GAEjDR,EAAaR,QAAQC,YAAc,oBACnCe,EAAQnD,kBAAkBP,IAAIkD,EAAcwB,GAEzCA,CACX,CACAC,WAAWtH,EAAOqG,EAAU,IAAIpD,GAC5BjC,KAAKuE,oBACL,MAAMgC,EAAgBvG,KAAKwG,oBAAoBxH,GAC/C,IAAKuH,GAAiBzF,EAAc9B,GAChC,MAAM,IAAI6B,MAAM,wDAAwD7B,EAAMuD,eAGlF,GADAvC,KAAKuF,gCAAgCvG,EAAO,OACxCuH,EAAe,CACf,MAAMf,EAASe,EAAcrD,KAAIuD,GAAQzG,KAAKyF,oBAAoBgB,EAAMpB,KAExE,OADArF,KAAK0F,iCAAiC1G,EAAOwG,EAAQ,OAC9CA,CACX,CACA,MAAMA,EAAS,CAACxF,KAAK4F,UAAU5G,EAAOqG,IAEtC,OADArF,KAAK0F,iCAAiC1G,EAAOwG,EAAQ,OAC9CA,CACX,CACAkB,aAAa1H,EAAO2H,GAAY,GAE5B,OADA3G,KAAKuE,oBACGvE,KAAK8D,UAAUhC,IAAI9C,IACtB2H,IACI3G,KAAK6D,SAAU,IAChB7D,KAAK6D,OAAO6C,aAAa1H,GAAO,EAC5C,CACA4H,QACI5G,KAAKuE,oBACLvE,KAAK8D,UAAU/B,QACf/B,KAAK+D,aAAaN,cAAc1B,QAChC/B,KAAK+D,aAAaL,eAAe3B,OACrC,CACA8E,iBACI7G,KAAKuE,oBACL,IAAK,MAAOvF,EAAOuH,KAAkBvG,KAAK8D,UAAUvC,UAChDvB,KAAK8D,UAAUjC,OAAO7C,EAAOuH,EACxBO,QAAOjC,IAAiBrF,EAAgBqF,EAAavF,YACrD4D,KAAI2B,IACLA,EAAaK,cAAWzF,EACjBoF,KAGnB,CACAkC,uBACI/G,KAAKuE,oBACL,MAAMyC,EAAiB,IAAIpD,EAA4B5D,MACvD,IAAK,MAAOhB,EAAOuH,KAAkBvG,KAAK8D,UAAUvC,UAC5CgF,EAAcU,MAAK,EAAG5C,aAAcA,EAAQC,YAAc,qBAC1D0C,EAAelD,UAAUjC,OAAO7C,EAAOuH,EAAcrD,KAAI2B,GACjDA,EAAaR,QAAQC,YAAc,kBAC5B,CACHhF,SAAUuF,EAAavF,SACvB+E,QAASQ,EAAaR,SAGvBQ,KAInB,OAAOmC,CACX,CACAE,iBAAiBlI,EAAOiH,EAAU5B,EAAU,CAAE2B,UAAW,WACrDhG,KAAK+D,aAAaN,cAAc9B,IAAI3C,EAAO,CACvCiH,SAAUA,EACV5B,QAASA,GAEjB,CACA8C,gBAAgBnI,EAAOiH,EAAU5B,EAAU,CAAE2B,UAAW,WACpDhG,KAAK+D,aAAaL,eAAe/B,IAAI3C,EAAO,CACxCiH,SAAUA,EACV5B,QAASA,GAEjB,CACA+C,UACI,OEpLkBC,EFoLDrH,KEpLUsH,OFoLJ,EEpLmBC,EFoLH,YACnCvH,KAAKgE,UAAW,EAChB,MAAMwD,EAAW,GACjBxH,KAAKiE,YAAYxF,SAAQgJ,IACrB,MAAMC,EAAeD,EAAWL,UAC5BM,GACAF,EAAS5F,KAAK8F,EAClB,UAEEC,QAAQC,IAAIJ,EACtB,EE5LG,KAFoCK,OFoLR,KElLjBA,EAAIF,WAAU,SAAUvC,EAAS0C,GAC/C,SAASC,EAAUhK,GAAS,IAAMiK,EAAKT,EAAUU,KAAKlK,GAAS,CAAE,MAAOgF,GAAK+E,EAAO/E,EAAI,CAAE,CAC1F,SAASmF,EAASnK,GAAS,IAAMiK,EAAKT,EAAiB,MAAExJ,GAAS,CAAE,MAAOgF,GAAK+E,EAAO/E,EAAI,CAAE,CAC7F,SAASiF,EAAKxC,GAJlB,IAAezH,EAIayH,EAAO2C,KAAO/C,EAAQI,EAAOzH,QAJ1CA,EAIyDyH,EAAOzH,MAJhDA,aAAiB8J,EAAI9J,EAAQ,IAAI8J,GAAE,SAAUzC,GAAWA,EAAQrH,EAAQ,KAIjBqK,KAAKL,EAAWG,EAAW,CAC7GF,GAAMT,EAAYA,EAAUc,MAAMhB,EAASC,GAAc,KAAKW,OAClE,IAPG,IAAmBZ,EAASC,EAAYO,EAAGN,CF+L9C,CACAjC,gBAAgBtG,GACZ,OAAIgB,KAAK0G,aAAa1H,GACXgB,KAAK8D,UAAUvG,IAAIyB,GAE1BgB,KAAK6D,OACE7D,KAAK6D,OAAOyB,gBAAgBtG,GAEhC,IACX,CACAwH,oBAAoBxH,GAChB,OAAIgB,KAAK0G,aAAa1H,GACXgB,KAAK8D,UAAUtC,OAAOxC,GAE7BgB,KAAK6D,OACE7D,KAAK6D,OAAO2C,oBAAoBxH,GAEpC,IACX,CACA4G,UAAUxD,EAAMiD,GACZ,GAAIjD,aAAgBvC,EAChB,OAAOuC,EAAKlC,aAAahC,GAAW8B,KAAKoF,QAAQlH,EAAQmH,KAE7D,MAAMH,EAAW,MACb,MAAMoD,EAAY3E,EAASpG,IAAI6E,GAC/B,IAAKkG,GAAkC,IAArBA,EAAU5G,OAAc,CACtC,GAAoB,IAAhBU,EAAKV,OACL,OAAO,IAAIU,EAGX,MAAM,IAAIvB,MAAM,2BAA2BuB,EAAK3B,QAExD,CACA,MAAMtC,EAASmK,EAAUpF,IAAIlD,KAAKuI,cAAclD,EAASjD,IACzD,OAAO,IAAIA,KAAQjE,EACtB,EAZgB,GGzRlB,IAAsBJ,EHySrB,MGxSyB,mBADJA,EHsSJmH,GGrSJkC,SAEErJ,EAAMqJ,QACV1F,OAAS,GHmShB1B,KAAKiE,YAAYuE,IAAItD,GAElBA,CACX,CACAqD,cAAclD,EAASjD,GACnB,MAAO,CAACqG,EAAO/F,KACX,IACI,OAAI3B,EAAkB0H,GACdxH,EAAsBwH,GACfA,EAAMC,SACP1I,KAAKoF,QAAQqD,EAAM7J,WAAWA,UAAUoB,KAAKsG,WAAWmC,EAAMzJ,UAAWyJ,EAAMvJ,eAC/Ec,KAAKoF,QAAQqD,EAAM7J,WAAWA,UAAUoB,KAAKoF,QAAQqD,EAAMzJ,MAAOqG,MAAaoD,EAAMvJ,eAGpFuJ,EAAMC,SACP1I,KAAKsG,WAAWmC,EAAMzJ,OACtBgB,KAAKoF,QAAQqD,EAAMzJ,MAAOqG,GAG/BpE,EAAsBwH,GACpBzI,KAAKoF,QAAQqD,EAAM7J,UAAWyG,GAASzG,UAAUoB,KAAKoF,QAAQqD,EAAMzJ,MAAOqG,MAAaoD,EAAMvJ,eAElGc,KAAKoF,QAAQqD,EAAOpD,EAC/B,CACA,MAAOtC,GACH,MAAM,IAAIlC,MAAMsB,EAAgBC,EAAMM,EAAKK,GAC/C,EAER,CACAwB,oBACI,GAAIvE,KAAKgE,SACL,MAAM,IAAInD,MAAM,kFAExB,EAEG,MAAMqE,EAAW,IAAItB,EI/R5B,EAvCA,WACI,OAAO,SAAU1F,GACb,MAAMoK,EAAYrK,EAAaC,GAC/B,OAAO,cAAcA,EACjB4B,eAAeX,GACXwJ,SAASxJ,EAAKyJ,OAAON,EAAUO,MAAM1J,EAAKuC,QAAQwB,KAAI,CAAC4F,EAAMC,KACzD,IACI,OAAIhI,EAAkB+H,GACd7H,EAAsB6H,GACfA,EAAKJ,SACN,UACWI,EAAKlK,WACbA,UAAU,aAA2BkK,EAAK9J,UAAW8J,EAAK5J,eAC7D,UACW4J,EAAKlK,WACbA,UAAU,UAAwBkK,EAAK9J,UAAW8J,EAAK5J,eAGzD4J,EAAKJ,SACN,aAA2BI,EAAK9J,OAChC,UAAwB8J,EAAK9J,OAGlCiC,EAAsB6H,GACpB,UACMA,EAAKlK,WACbA,UAAU,UAAwBkK,EAAK9J,UAAW8J,EAAK5J,eAEzD,UAAwB4J,EACnC,CACA,MAAO/F,GACH,MAAMiG,EAAWD,EAAQ5J,EAAKuC,OAC9B,MAAM,IAAIb,MAAMsB,EAAgBjE,EAAQ8K,EAAUjG,GACtD,MAER,EAER,CACJ,ECtCA,EAHA,SAAgB/D,GACZ,OAAON,EAA6BM,EACxC,ECIA,EALA,WACI,OAAO,SAAUd,GACbyF,EAAShC,IAAIzD,EAAQD,EAAaC,GACtC,CACJ,ECKA,EATA,SAAkBqI,EAAgB,IAC9B,OAAO,SAAUrI,GAKb,OAJAqI,EAAc9H,SAASwK,IACnB,IAAI,MAAEjK,EAAK,QAAEqF,GAAY4E,EAAI3J,ELmClC,SAAgB4J,EAAGnG,GACtB,IAAIoG,EAAI,CAAC,EACT,IAAK,IAAIC,KAAKF,EAAO9L,OAAOM,UAAUC,eAAeC,KAAKsL,EAAGE,IAAMrG,EAAEsG,QAAQD,GAAK,IAC9ED,EAAEC,GAAKF,EAAEE,IACb,GAAS,MAALF,GAAqD,mBAAjC9L,OAAOkM,sBACtB,KAAIC,EAAI,EAAb,IAAgBH,EAAIhM,OAAOkM,sBAAsBJ,GAAIK,EAAIH,EAAE1H,OAAQ6H,IAC3DxG,EAAEsG,QAAQD,EAAEG,IAAM,GAAKnM,OAAOM,UAAU8L,qBAAqB5L,KAAKsL,EAAGE,EAAEG,MACvEJ,EAAEC,EAAEG,IAAML,EAAEE,EAAEG,IAF4B,CAItD,OAAOJ,CACX,CK7CoDM,CAAOR,EAAI,CAAC,QAAS,YAC7D,OAAO,WAAyBjK,EAAOM,EAAU+E,EAAQ,IAEtDnG,CACX,CACJ,ECFA,EANA,WACI,OAAO,SAAUA,GACb,IAAaA,GACb,oBAAkCA,EACtC,CACJ,ECFA,EAJA,SAAmBc,GAEf,OAAON,EADM,CAAEM,QAAO0J,UAAU,GAEpC,ECMA,EATA,SAAgC1J,EAAO0K,KAAgBvK,GAOnD,OAAOT,EANM,CACTM,QACA0J,UAAU,EACV9J,UAAW8K,EACXxK,cAAeC,GAGvB,ECFA,EANA,SAA6BH,EAAO0K,KAAgBvK,GAChD,OAAOT,EAA6BM,EAAO,CACvCC,eAAgByK,EAChBvK,KAAMA,GAEd,ECJe,SAASwK,EAAOrF,EAAWtF,GACtC,OAAO,SAAUd,GACb,IAAaA,GACb,WAAyBc,GAASd,EAAQA,EAAQ,CAC9CoG,aAER,CACJ,CCTe,SAASsF,EAAuBC,GAC3C,IAAI3E,EACJ,OAAQ4E,IACYrK,MAAZyF,IACAA,EAAW2E,EAAYC,IAEpB5E,EAEf,CCRe,SAAS6E,EAAmCF,GACvD,MAAMG,EAAQ,IAAIC,QAClB,OAAQH,IACJ,IAAI5E,EAAW8E,EAAMzM,IAAIuM,GAKzB,OAJgBrK,MAAZyF,IACAA,EAAW2E,EAAYC,GACvBE,EAAMrI,IAAImI,EAAqB5E,IAE5BA,CAAQ,CAEvB,CCVe,SAASgF,EAA2BC,EAAWC,EAAiBC,EAAkBC,GAAa,GAC1G,IAAIpF,EACAqF,EACJ,OAAQT,IACJ,MAAMU,EAAmBL,EAAUL,GASnC,OARKQ,GAAcC,IAAsBC,IAEjCtF,GADCqF,EAAoBC,GACVV,EAAoB1E,QAAQgF,GAG5BN,EAAoB1E,QAAQiF,IAGxCnF,CAAQ,CAEvB,CCfA,GAAuB,oBAAZ9G,UAA4BA,QAAQC,YAC3C,MAAM,IAAIwC,MAAM,kH","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tsyringe/dist/esm2015/types/lifecycle.js","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./node_modules/tsyringe/dist/esm2015/reflection-helpers.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/token-provider.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/value-provider.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/factory-provider.js","webpack:///./node_modules/tsyringe/dist/esm2015/lazy-helpers.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/injection-token.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/class-provider.js","webpack:///./node_modules/tsyringe/dist/esm2015/registry-base.js","webpack:///./node_modules/tsyringe/dist/esm2015/registry.js","webpack:///./node_modules/tsyringe/dist/esm2015/resolution-context.js","webpack:///./node_modules/tsyringe/dist/esm2015/error-helpers.js","webpack:///./node_modules/tsyringe/dist/esm2015/interceptors.js","webpack:///./node_modules/tsyringe/dist/esm2015/dependency-container.js","webpack:///./node_modules/tsyringe/dist/esm2015/providers/provider.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/tsyringe/dist/esm2015/types/disposable.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/auto-injectable.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/inject.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/injectable.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/registry.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/singleton.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/inject-all.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/inject-all-with-transform.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/inject-with-transform.js","webpack:///./node_modules/tsyringe/dist/esm2015/decorators/scoped.js","webpack:///./node_modules/tsyringe/dist/esm2015/factories/instance-caching-factory.js","webpack:///./node_modules/tsyringe/dist/esm2015/factories/instance-per-container-caching-factory.js","webpack:///./node_modules/tsyringe/dist/esm2015/factories/predicate-aware-class-factory.js","webpack:///./node_modules/tsyringe/dist/esm2015/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","var Lifecycle;\n(function (Lifecycle) {\n    Lifecycle[Lifecycle[\"Transient\"] = 0] = \"Transient\";\n    Lifecycle[Lifecycle[\"Singleton\"] = 1] = \"Singleton\";\n    Lifecycle[Lifecycle[\"ResolutionScoped\"] = 2] = \"ResolutionScoped\";\n    Lifecycle[Lifecycle[\"ContainerScoped\"] = 3] = \"ContainerScoped\";\n})(Lifecycle || (Lifecycle = {}));\nexport default Lifecycle;\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const INJECTION_TOKEN_METADATA_KEY = \"injectionTokens\";\nexport function getParamInfo(target) {\n    const params = Reflect.getMetadata(\"design:paramtypes\", target) || [];\n    const injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};\n    Object.keys(injectionTokens).forEach(key => {\n        params[+key] = injectionTokens[key];\n    });\n    return params;\n}\nexport function defineInjectionTokenMetadata(data, transform) {\n    return function (target, _propertyKey, parameterIndex) {\n        const descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};\n        descriptors[parameterIndex] = transform\n            ? {\n                token: data,\n                transform: transform.transformToken,\n                transformArgs: transform.args || []\n            }\n            : data;\n        Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);\n    };\n}\n","export function isTokenProvider(provider) {\n    return !!provider.useToken;\n}\n","export function isValueProvider(provider) {\n    return provider.useValue != undefined;\n}\n","export function isFactoryProvider(provider) {\n    return !!provider.useFactory;\n}\n","export class DelayedConstructor {\n    constructor(wrap) {\n        this.wrap = wrap;\n        this.reflectMethods = [\n            \"get\",\n            \"getPrototypeOf\",\n            \"setPrototypeOf\",\n            \"getOwnPropertyDescriptor\",\n            \"defineProperty\",\n            \"has\",\n            \"set\",\n            \"deleteProperty\",\n            \"apply\",\n            \"construct\",\n            \"ownKeys\"\n        ];\n    }\n    createProxy(createObject) {\n        const target = {};\n        let init = false;\n        let value;\n        const delayedObject = () => {\n            if (!init) {\n                value = createObject(this.wrap());\n                init = true;\n            }\n            return value;\n        };\n        return new Proxy(target, this.createHandler(delayedObject));\n    }\n    createHandler(delayedObject) {\n        const handler = {};\n        const install = (name) => {\n            handler[name] = (...args) => {\n                args[0] = delayedObject();\n                const method = Reflect[name];\n                return method(...args);\n            };\n        };\n        this.reflectMethods.forEach(install);\n        return handler;\n    }\n}\nexport function delay(wrappedConstructor) {\n    if (typeof wrappedConstructor === \"undefined\") {\n        throw new Error(\"Attempt to `delay` undefined. Constructor must be wrapped in a callback\");\n    }\n    return new DelayedConstructor(wrappedConstructor);\n}\n","import { DelayedConstructor } from \"../lazy-helpers\";\nexport function isNormalToken(token) {\n    return typeof token === \"string\" || typeof token === \"symbol\";\n}\nexport function isTokenDescriptor(descriptor) {\n    return (typeof descriptor === \"object\" &&\n        \"token\" in descriptor &&\n        \"multiple\" in descriptor);\n}\nexport function isTransformDescriptor(descriptor) {\n    return (typeof descriptor === \"object\" &&\n        \"token\" in descriptor &&\n        \"transform\" in descriptor);\n}\nexport function isConstructorToken(token) {\n    return typeof token === \"function\" || token instanceof DelayedConstructor;\n}\n","export function isClassProvider(provider) {\n    return !!provider.useClass;\n}\n","export default class RegistryBase {\n    constructor() {\n        this._registryMap = new Map();\n    }\n    entries() {\n        return this._registryMap.entries();\n    }\n    getAll(key) {\n        this.ensure(key);\n        return this._registryMap.get(key);\n    }\n    get(key) {\n        this.ensure(key);\n        const value = this._registryMap.get(key);\n        return value[value.length - 1] || null;\n    }\n    set(key, value) {\n        this.ensure(key);\n        this._registryMap.get(key).push(value);\n    }\n    setAll(key, value) {\n        this._registryMap.set(key, value);\n    }\n    has(key) {\n        this.ensure(key);\n        return this._registryMap.get(key).length > 0;\n    }\n    clear() {\n        this._registryMap.clear();\n    }\n    ensure(key) {\n        if (!this._registryMap.has(key)) {\n            this._registryMap.set(key, []);\n        }\n    }\n}\n","import RegistryBase from \"./registry-base\";\nexport default class Registry extends RegistryBase {\n}\n","export default class ResolutionContext {\n    constructor() {\n        this.scopedResolutions = new Map();\n    }\n}\n","function formatDependency(params, idx) {\n    if (params === null) {\n        return `at position #${idx}`;\n    }\n    const argName = params.split(\",\")[idx].trim();\n    return `\"${argName}\" at position #${idx}`;\n}\nfunction composeErrorMessage(msg, e, indent = \"    \") {\n    return [msg, ...e.message.split(\"\\n\").map(l => indent + l)].join(\"\\n\");\n}\nexport function formatErrorCtor(ctor, paramIdx, error) {\n    const [, params = null] = ctor.toString().match(/constructor\\(([\\w, ]+)\\)/) || [];\n    const dep = formatDependency(params, paramIdx);\n    return composeErrorMessage(`Cannot inject the dependency ${dep} of \"${ctor.name}\" constructor. Reason:`, error);\n}\n","import RegistryBase from \"./registry-base\";\nexport class PreResolutionInterceptors extends RegistryBase {\n}\nexport class PostResolutionInterceptors extends RegistryBase {\n}\nexport default class Interceptors {\n    constructor() {\n        this.preResolution = new PreResolutionInterceptors();\n        this.postResolution = new PostResolutionInterceptors();\n    }\n}\n","import { __awaiter } from \"tslib\";\nimport { isClassProvider, isFactoryProvider, isNormalToken, isTokenProvider, isValueProvider } from \"./providers\";\nimport { isProvider } from \"./providers/provider\";\nimport { isConstructorToken, isTokenDescriptor, isTransformDescriptor } from \"./providers/injection-token\";\nimport Registry from \"./registry\";\nimport Lifecycle from \"./types/lifecycle\";\nimport ResolutionContext from \"./resolution-context\";\nimport { formatErrorCtor } from \"./error-helpers\";\nimport { DelayedConstructor } from \"./lazy-helpers\";\nimport { isDisposable } from \"./types/disposable\";\nimport Interceptors from \"./interceptors\";\nexport const typeInfo = new Map();\nclass InternalDependencyContainer {\n    constructor(parent) {\n        this.parent = parent;\n        this._registry = new Registry();\n        this.interceptors = new Interceptors();\n        this.disposed = false;\n        this.disposables = new Set();\n    }\n    register(token, providerOrConstructor, options = { lifecycle: Lifecycle.Transient }) {\n        this.ensureNotDisposed();\n        let provider;\n        if (!isProvider(providerOrConstructor)) {\n            provider = { useClass: providerOrConstructor };\n        }\n        else {\n            provider = providerOrConstructor;\n        }\n        if (isTokenProvider(provider)) {\n            const path = [token];\n            let tokenProvider = provider;\n            while (tokenProvider != null) {\n                const currentToken = tokenProvider.useToken;\n                if (path.includes(currentToken)) {\n                    throw new Error(`Token registration cycle detected! ${[...path, currentToken].join(\" -> \")}`);\n                }\n                path.push(currentToken);\n                const registration = this._registry.get(currentToken);\n                if (registration && isTokenProvider(registration.provider)) {\n                    tokenProvider = registration.provider;\n                }\n                else {\n                    tokenProvider = null;\n                }\n            }\n        }\n        if (options.lifecycle === Lifecycle.Singleton ||\n            options.lifecycle == Lifecycle.ContainerScoped ||\n            options.lifecycle == Lifecycle.ResolutionScoped) {\n            if (isValueProvider(provider) || isFactoryProvider(provider)) {\n                throw new Error(`Cannot use lifecycle \"${Lifecycle[options.lifecycle]}\" with ValueProviders or FactoryProviders`);\n            }\n        }\n        this._registry.set(token, { provider, options });\n        return this;\n    }\n    registerType(from, to) {\n        this.ensureNotDisposed();\n        if (isNormalToken(to)) {\n            return this.register(from, {\n                useToken: to\n            });\n        }\n        return this.register(from, {\n            useClass: to\n        });\n    }\n    registerInstance(token, instance) {\n        this.ensureNotDisposed();\n        return this.register(token, {\n            useValue: instance\n        });\n    }\n    registerSingleton(from, to) {\n        this.ensureNotDisposed();\n        if (isNormalToken(from)) {\n            if (isNormalToken(to)) {\n                return this.register(from, {\n                    useToken: to\n                }, { lifecycle: Lifecycle.Singleton });\n            }\n            else if (to) {\n                return this.register(from, {\n                    useClass: to\n                }, { lifecycle: Lifecycle.Singleton });\n            }\n            throw new Error('Cannot register a type name as a singleton without a \"to\" token');\n        }\n        let useClass = from;\n        if (to && !isNormalToken(to)) {\n            useClass = to;\n        }\n        return this.register(from, {\n            useClass\n        }, { lifecycle: Lifecycle.Singleton });\n    }\n    resolve(token, context = new ResolutionContext()) {\n        this.ensureNotDisposed();\n        const registration = this.getRegistration(token);\n        if (!registration && isNormalToken(token)) {\n            throw new Error(`Attempted to resolve unregistered dependency token: \"${token.toString()}\"`);\n        }\n        this.executePreResolutionInterceptor(token, \"Single\");\n        if (registration) {\n            const result = this.resolveRegistration(registration, context);\n            this.executePostResolutionInterceptor(token, result, \"Single\");\n            return result;\n        }\n        if (isConstructorToken(token)) {\n            const result = this.construct(token, context);\n            this.executePostResolutionInterceptor(token, result, \"Single\");\n            return result;\n        }\n        throw new Error(\"Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.\");\n    }\n    executePreResolutionInterceptor(token, resolutionType) {\n        if (this.interceptors.preResolution.has(token)) {\n            const remainingInterceptors = [];\n            for (const interceptor of this.interceptors.preResolution.getAll(token)) {\n                if (interceptor.options.frequency != \"Once\") {\n                    remainingInterceptors.push(interceptor);\n                }\n                interceptor.callback(token, resolutionType);\n            }\n            this.interceptors.preResolution.setAll(token, remainingInterceptors);\n        }\n    }\n    executePostResolutionInterceptor(token, result, resolutionType) {\n        if (this.interceptors.postResolution.has(token)) {\n            const remainingInterceptors = [];\n            for (const interceptor of this.interceptors.postResolution.getAll(token)) {\n                if (interceptor.options.frequency != \"Once\") {\n                    remainingInterceptors.push(interceptor);\n                }\n                interceptor.callback(token, result, resolutionType);\n            }\n            this.interceptors.postResolution.setAll(token, remainingInterceptors);\n        }\n    }\n    resolveRegistration(registration, context) {\n        this.ensureNotDisposed();\n        if (registration.options.lifecycle === Lifecycle.ResolutionScoped &&\n            context.scopedResolutions.has(registration)) {\n            return context.scopedResolutions.get(registration);\n        }\n        const isSingleton = registration.options.lifecycle === Lifecycle.Singleton;\n        const isContainerScoped = registration.options.lifecycle === Lifecycle.ContainerScoped;\n        const returnInstance = isSingleton || isContainerScoped;\n        let resolved;\n        if (isValueProvider(registration.provider)) {\n            resolved = registration.provider.useValue;\n        }\n        else if (isTokenProvider(registration.provider)) {\n            resolved = returnInstance\n                ? registration.instance ||\n                    (registration.instance = this.resolve(registration.provider.useToken, context))\n                : this.resolve(registration.provider.useToken, context);\n        }\n        else if (isClassProvider(registration.provider)) {\n            resolved = returnInstance\n                ? registration.instance ||\n                    (registration.instance = this.construct(registration.provider.useClass, context))\n                : this.construct(registration.provider.useClass, context);\n        }\n        else if (isFactoryProvider(registration.provider)) {\n            resolved = registration.provider.useFactory(this);\n        }\n        else {\n            resolved = this.construct(registration.provider, context);\n        }\n        if (registration.options.lifecycle === Lifecycle.ResolutionScoped) {\n            context.scopedResolutions.set(registration, resolved);\n        }\n        return resolved;\n    }\n    resolveAll(token, context = new ResolutionContext()) {\n        this.ensureNotDisposed();\n        const registrations = this.getAllRegistrations(token);\n        if (!registrations && isNormalToken(token)) {\n            throw new Error(`Attempted to resolve unregistered dependency token: \"${token.toString()}\"`);\n        }\n        this.executePreResolutionInterceptor(token, \"All\");\n        if (registrations) {\n            const result = registrations.map(item => this.resolveRegistration(item, context));\n            this.executePostResolutionInterceptor(token, result, \"All\");\n            return result;\n        }\n        const result = [this.construct(token, context)];\n        this.executePostResolutionInterceptor(token, result, \"All\");\n        return result;\n    }\n    isRegistered(token, recursive = false) {\n        this.ensureNotDisposed();\n        return (this._registry.has(token) ||\n            (recursive &&\n                (this.parent || false) &&\n                this.parent.isRegistered(token, true)));\n    }\n    reset() {\n        this.ensureNotDisposed();\n        this._registry.clear();\n        this.interceptors.preResolution.clear();\n        this.interceptors.postResolution.clear();\n    }\n    clearInstances() {\n        this.ensureNotDisposed();\n        for (const [token, registrations] of this._registry.entries()) {\n            this._registry.setAll(token, registrations\n                .filter(registration => !isValueProvider(registration.provider))\n                .map(registration => {\n                registration.instance = undefined;\n                return registration;\n            }));\n        }\n    }\n    createChildContainer() {\n        this.ensureNotDisposed();\n        const childContainer = new InternalDependencyContainer(this);\n        for (const [token, registrations] of this._registry.entries()) {\n            if (registrations.some(({ options }) => options.lifecycle === Lifecycle.ContainerScoped)) {\n                childContainer._registry.setAll(token, registrations.map(registration => {\n                    if (registration.options.lifecycle === Lifecycle.ContainerScoped) {\n                        return {\n                            provider: registration.provider,\n                            options: registration.options\n                        };\n                    }\n                    return registration;\n                }));\n            }\n        }\n        return childContainer;\n    }\n    beforeResolution(token, callback, options = { frequency: \"Always\" }) {\n        this.interceptors.preResolution.set(token, {\n            callback: callback,\n            options: options\n        });\n    }\n    afterResolution(token, callback, options = { frequency: \"Always\" }) {\n        this.interceptors.postResolution.set(token, {\n            callback: callback,\n            options: options\n        });\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.disposed = true;\n            const promises = [];\n            this.disposables.forEach(disposable => {\n                const maybePromise = disposable.dispose();\n                if (maybePromise) {\n                    promises.push(maybePromise);\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    getRegistration(token) {\n        if (this.isRegistered(token)) {\n            return this._registry.get(token);\n        }\n        if (this.parent) {\n            return this.parent.getRegistration(token);\n        }\n        return null;\n    }\n    getAllRegistrations(token) {\n        if (this.isRegistered(token)) {\n            return this._registry.getAll(token);\n        }\n        if (this.parent) {\n            return this.parent.getAllRegistrations(token);\n        }\n        return null;\n    }\n    construct(ctor, context) {\n        if (ctor instanceof DelayedConstructor) {\n            return ctor.createProxy((target) => this.resolve(target, context));\n        }\n        const instance = (() => {\n            const paramInfo = typeInfo.get(ctor);\n            if (!paramInfo || paramInfo.length === 0) {\n                if (ctor.length === 0) {\n                    return new ctor();\n                }\n                else {\n                    throw new Error(`TypeInfo not known for \"${ctor.name}\"`);\n                }\n            }\n            const params = paramInfo.map(this.resolveParams(context, ctor));\n            return new ctor(...params);\n        })();\n        if (isDisposable(instance)) {\n            this.disposables.add(instance);\n        }\n        return instance;\n    }\n    resolveParams(context, ctor) {\n        return (param, idx) => {\n            try {\n                if (isTokenDescriptor(param)) {\n                    if (isTransformDescriptor(param)) {\n                        return param.multiple\n                            ? this.resolve(param.transform).transform(this.resolveAll(param.token), ...param.transformArgs)\n                            : this.resolve(param.transform).transform(this.resolve(param.token, context), ...param.transformArgs);\n                    }\n                    else {\n                        return param.multiple\n                            ? this.resolveAll(param.token)\n                            : this.resolve(param.token, context);\n                    }\n                }\n                else if (isTransformDescriptor(param)) {\n                    return this.resolve(param.transform, context).transform(this.resolve(param.token, context), ...param.transformArgs);\n                }\n                return this.resolve(param, context);\n            }\n            catch (e) {\n                throw new Error(formatErrorCtor(ctor, idx, e));\n            }\n        };\n    }\n    ensureNotDisposed() {\n        if (this.disposed) {\n            throw new Error(\"This container has been disposed, you cannot interact with a disposed container\");\n        }\n    }\n}\nexport const instance = new InternalDependencyContainer();\nexport default instance;\n","import { isClassProvider } from \"./class-provider\";\nimport { isValueProvider } from \"./value-provider\";\nimport { isTokenProvider } from \"./token-provider\";\nimport { isFactoryProvider } from \"./factory-provider\";\nexport function isProvider(provider) {\n    return (isClassProvider(provider) ||\n        isValueProvider(provider) ||\n        isTokenProvider(provider) ||\n        isFactoryProvider(provider));\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export function isDisposable(value) {\n    if (typeof value.dispose !== \"function\")\n        return false;\n    const disposeFun = value.dispose;\n    if (disposeFun.length > 0) {\n        return false;\n    }\n    return true;\n}\n","import { getParamInfo } from \"../reflection-helpers\";\nimport { instance as globalContainer } from \"../dependency-container\";\nimport { isTokenDescriptor, isTransformDescriptor } from \"../providers/injection-token\";\nimport { formatErrorCtor } from \"../error-helpers\";\nfunction autoInjectable() {\n    return function (target) {\n        const paramInfo = getParamInfo(target);\n        return class extends target {\n            constructor(...args) {\n                super(...args.concat(paramInfo.slice(args.length).map((type, index) => {\n                    try {\n                        if (isTokenDescriptor(type)) {\n                            if (isTransformDescriptor(type)) {\n                                return type.multiple\n                                    ? globalContainer\n                                        .resolve(type.transform)\n                                        .transform(globalContainer.resolveAll(type.token), ...type.transformArgs)\n                                    : globalContainer\n                                        .resolve(type.transform)\n                                        .transform(globalContainer.resolve(type.token), ...type.transformArgs);\n                            }\n                            else {\n                                return type.multiple\n                                    ? globalContainer.resolveAll(type.token)\n                                    : globalContainer.resolve(type.token);\n                            }\n                        }\n                        else if (isTransformDescriptor(type)) {\n                            return globalContainer\n                                .resolve(type.transform)\n                                .transform(globalContainer.resolve(type.token), ...type.transformArgs);\n                        }\n                        return globalContainer.resolve(type);\n                    }\n                    catch (e) {\n                        const argIndex = index + args.length;\n                        throw new Error(formatErrorCtor(target, argIndex, e));\n                    }\n                })));\n            }\n        };\n    };\n}\nexport default autoInjectable;\n","import { defineInjectionTokenMetadata } from \"../reflection-helpers\";\nfunction inject(token) {\n    return defineInjectionTokenMetadata(token);\n}\nexport default inject;\n","import { getParamInfo } from \"../reflection-helpers\";\nimport { typeInfo } from \"../dependency-container\";\nfunction injectable() {\n    return function (target) {\n        typeInfo.set(target, getParamInfo(target));\n    };\n}\nexport default injectable;\n","import { __rest } from \"tslib\";\nimport { instance as globalContainer } from \"../dependency-container\";\nfunction registry(registrations = []) {\n    return function (target) {\n        registrations.forEach((_a) => {\n            var { token, options } = _a, provider = __rest(_a, [\"token\", \"options\"]);\n            return globalContainer.register(token, provider, options);\n        });\n        return target;\n    };\n}\nexport default registry;\n","import injectable from \"./injectable\";\nimport { instance as globalContainer } from \"../dependency-container\";\nfunction singleton() {\n    return function (target) {\n        injectable()(target);\n        globalContainer.registerSingleton(target);\n    };\n}\nexport default singleton;\n","import { defineInjectionTokenMetadata } from \"../reflection-helpers\";\nfunction injectAll(token) {\n    const data = { token, multiple: true };\n    return defineInjectionTokenMetadata(data);\n}\nexport default injectAll;\n","import { defineInjectionTokenMetadata } from \"../reflection-helpers\";\nfunction injectAllWithTransform(token, transformer, ...args) {\n    const data = {\n        token,\n        multiple: true,\n        transform: transformer,\n        transformArgs: args\n    };\n    return defineInjectionTokenMetadata(data);\n}\nexport default injectAllWithTransform;\n","import { defineInjectionTokenMetadata } from \"../reflection-helpers\";\nfunction injectWithTransform(token, transformer, ...args) {\n    return defineInjectionTokenMetadata(token, {\n        transformToken: transformer,\n        args: args\n    });\n}\nexport default injectWithTransform;\n","import injectable from \"./injectable\";\nimport { instance as globalContainer } from \"../dependency-container\";\nexport default function scoped(lifecycle, token) {\n    return function (target) {\n        injectable()(target);\n        globalContainer.register(token || target, target, {\n            lifecycle\n        });\n    };\n}\n","export default function instanceCachingFactory(factoryFunc) {\n    let instance;\n    return (dependencyContainer) => {\n        if (instance == undefined) {\n            instance = factoryFunc(dependencyContainer);\n        }\n        return instance;\n    };\n}\n","export default function instancePerContainerCachingFactory(factoryFunc) {\n    const cache = new WeakMap();\n    return (dependencyContainer) => {\n        let instance = cache.get(dependencyContainer);\n        if (instance == undefined) {\n            instance = factoryFunc(dependencyContainer);\n            cache.set(dependencyContainer, instance);\n        }\n        return instance;\n    };\n}\n","export default function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching = true) {\n    let instance;\n    let previousPredicate;\n    return (dependencyContainer) => {\n        const currentPredicate = predicate(dependencyContainer);\n        if (!useCaching || previousPredicate !== currentPredicate) {\n            if ((previousPredicate = currentPredicate)) {\n                instance = dependencyContainer.resolve(trueConstructor);\n            }\n            else {\n                instance = dependencyContainer.resolve(falseConstructor);\n            }\n        }\n        return instance;\n    };\n}\n","if (typeof Reflect === \"undefined\" || !Reflect.getMetadata) {\n    throw new Error(`tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point.`);\n}\nexport { Lifecycle } from \"./types\";\nexport * from \"./decorators\";\nexport * from \"./factories\";\nexport * from \"./providers\";\nexport { delay } from \"./lazy-helpers\";\nexport { instance as container } from \"./dependency-container\";\n"],"names":["Lifecycle","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","INJECTION_TOKEN_METADATA_KEY","getParamInfo","target","params","Reflect","getMetadata","injectionTokens","getOwnMetadata","keys","forEach","defineInjectionTokenMetadata","data","transform","_propertyKey","parameterIndex","descriptors","token","transformToken","transformArgs","args","defineMetadata","isTokenProvider","provider","useToken","isValueProvider","undefined","useValue","isFactoryProvider","useFactory","DelayedConstructor","constructor","wrap","this","reflectMethods","createProxy","createObject","init","Proxy","createHandler","delayedObject","handler","name","method","delay","wrappedConstructor","Error","isNormalToken","isTokenDescriptor","descriptor","isTransformDescriptor","isClassProvider","useClass","RegistryBase","_registryMap","Map","entries","getAll","ensure","length","set","push","setAll","has","clear","Registry","ResolutionContext","scopedResolutions","formatErrorCtor","ctor","paramIdx","error","toString","match","dep","idx","split","trim","formatDependency","msg","e","indent","message","map","l","join","composeErrorMessage","PreResolutionInterceptors","PostResolutionInterceptors","Interceptors","preResolution","postResolution","typeInfo","InternalDependencyContainer","parent","_registry","interceptors","disposed","disposables","Set","register","providerOrConstructor","options","lifecycle","ensureNotDisposed","isProvider","path","tokenProvider","currentToken","includes","registration","registerType","from","to","registerInstance","instance","registerSingleton","resolve","context","getRegistration","executePreResolutionInterceptor","result","resolveRegistration","executePostResolutionInterceptor","isConstructorToken","construct","resolutionType","remainingInterceptors","interceptor","frequency","callback","isSingleton","isContainerScoped","returnInstance","resolved","resolveAll","registrations","getAllRegistrations","item","isRegistered","recursive","reset","clearInstances","filter","createChildContainer","childContainer","some","beforeResolution","afterResolution","dispose","thisArg","_arguments","generator","promises","disposable","maybePromise","Promise","all","P","reject","fulfilled","step","next","rejected","done","then","apply","paramInfo","resolveParams","add","param","multiple","super","concat","slice","type","index","argIndex","_a","s","t","p","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","__rest","transformer","scoped","instanceCachingFactory","factoryFunc","dependencyContainer","instancePerContainerCachingFactory","cache","WeakMap","predicateAwareClassFactory","predicate","trueConstructor","falseConstructor","useCaching","previousPredicate","currentPredicate"],"sourceRoot":""}