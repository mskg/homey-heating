/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app/helper/AsyncDebounce.ts":
/*!*****************************************!*\
  !*** ./src/app/helper/AsyncDebounce.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncDebounce = void 0;
/**
 * Debounces the async function by ms
 *
 * @param functionToDebounce it
 * @param wait in ms
 * @param leading true, if you want the first result
 */
function AsyncDebounce(functionToDebounce, wait, leading = false) {
    let resolvers = [];
    let timeout;
    let leadingResult;
    return function (...args) {
        return new Promise((resolve, _reject) => {
            const runImmediately = leading && !timeout;
            if (timeout != null) {
                clearTimeout(timeout);
            }
            timeout = setTimeout(() => {
                timeout = undefined;
                // @ts-ignore
                const res = leading ? leadingResult : functionToDebounce.apply(this, args);
                for (resolve of resolvers) {
                    resolve(res);
                }
                resolvers = [];
            }, wait);
            if (runImmediately) {
                // @ts-ignore
                leadingResult = functionToDebounce.apply(this, args);
                resolve(leadingResult);
            }
            else {
                resolvers.push(resolve);
            }
        });
    };
}
exports.AsyncDebounce = AsyncDebounce;


/***/ }),

/***/ "./src/app/helper/AsyncThrottle.ts":
/*!*****************************************!*\
  !*** ./src/app/helper/AsyncThrottle.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncThrottle = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * Throttles the call to the async function to maxCalls per duration.
 *
 * @param funcToThrottle The function to excute.
 * @param duration in ms
 * @param maxCalls per duration
 */
function AsyncThrottle(funcToThrottle, duration, maxCalls = 1) {
    let processCount = 0;
    let ticks = 0;
    // throttle function
    return function (...args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, _reject) => {
                const now = Date.now();
                if ((now - ticks) > 1) {
                    processCount = duration;
                    ticks = now;
                }
                else if (processCount < maxCalls) {
                    processCount++;
                }
                else {
                    ticks += duration;
                    processCount = 1;
                }
                // @ts-ignore
                setTimeout(() => { resolve(funcToThrottle.apply(this, args)); }, ticks - now);
            });
        });
    };
}
exports.AsyncThrottle = AsyncThrottle;


/***/ }),

/***/ "./src/app/helper/Mutex.ts":
/*!*********************************!*\
  !*** ./src/app/helper/Mutex.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mutex = void 0;
/**
 * Only one Thread can rule the world.
 *
 * const unlock = await new Mutex().lock();
 * {
 *      // code that should run locked
 * }
 * unlock();
 */
class Mutex {
    constructor() {
        // tslint:disable-next-line: no-empty
        this.locking = Promise.resolve(() => { });
    }
    lock() {
        let unlockNext;
        const willLock = new Promise((resolve) => unlockNext = () => {
            // @ts-ignore
            resolve();
        });
        const willUnlock = this.locking.then(() => unlockNext);
        this.locking = this.locking.then(() => willLock);
        return willUnlock;
    }
}
exports.Mutex = Mutex;


/***/ }),

/***/ "./src/app/helper/Retry.ts":
/*!*********************************!*\
  !*** ./src/app/helper/Retry.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Retry = void 0;
/**
 * Retry the async function.
 *
 * @param func call that
 * @param logger dump errors here
 * @param maxRetries so often
 * @param retryInterval wait this time in ms
 * @param incrementalBackoff double the time on each execution?
 * @param maxRetryInterval maximum duration per cycle
 */
function Retry(func, logger, maxRetries = 5, retryInterval = 1000, incrementalBackoff = false, maxRetryInterval = 10000) {
    return new Promise((resolve, reject) => {
        // call the func
        func()
            .then(resolve)
            // if it fails
            .catch((error) => {
            if (logger != null) {
                logger.debug(`Retry action ${maxRetries} times, waiting for ${retryInterval}`, error);
            }
            // we're done
            if (maxRetries - 1 <= 0) {
                reject(error);
                return;
            }
            // reexecute after retryInterval
            setTimeout(() => {
                // leave or double the time on incremental backoff
                const nextInterval = incrementalBackoff ? Math.min(maxRetryInterval, retryInterval * 2) : retryInterval;
                // retry one time less
                Retry(func, logger, maxRetries - 1, nextInterval, incrementalBackoff, maxRetryInterval)
                    .then(resolve, reject);
            }, retryInterval);
        });
    });
}
exports.Retry = Retry;


/***/ }),

/***/ "./src/app/helper/defaultPlan.ts":
/*!***************************************!*\
  !*** ./src/app/helper/defaultPlan.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_HEATING_DEVICES = exports.DEFAULT_HEATING_ZONES = exports.DEFAULT_HEATING_PLAN = exports.COOL = exports.INTERMEDIATE = exports.WARM = void 0;
const model_1 = __webpack_require__(/*! @app/model */ "@app/model");
exports.WARM = 20.5;
exports.INTERMEDIATE = 18.5;
exports.COOL = 16;
function bathroomSchedule() {
    const setPoints = [];
    for (const d of [model_1.Day.Monday, model_1.Day.Tuesday, model_1.Day.Wednesday, model_1.Day.Thursday, model_1.Day.Friday]) {
        setPoints.push({
            day: d,
            hour: 6,
            minute: 0,
            targetTemperature: exports.WARM,
        });
        setPoints.push({
            day: d,
            hour: 9,
            minute: 0,
            targetTemperature: exports.COOL,
        });
    }
    for (const d of [model_1.Day.Saturday, model_1.Day.Sunday]) {
        setPoints.push({
            day: d,
            hour: 9,
            minute: 0,
            targetTemperature: exports.INTERMEDIATE,
        });
        setPoints.push({
            day: d,
            hour: 23,
            minute: 30,
            targetTemperature: exports.COOL,
        });
    }
    return setPoints;
}
function mainSchedule() {
    const setPoints = [];
    for (const d of [model_1.Day.Monday, model_1.Day.Tuesday, model_1.Day.Wednesday, model_1.Day.Thursday, model_1.Day.Friday]) {
        setPoints.push({
            day: d,
            hour: 17,
            minute: 0,
            targetTemperature: exports.INTERMEDIATE,
        });
        setPoints.push({
            day: d,
            hour: 18,
            minute: 30,
            targetTemperature: exports.WARM,
        });
        setPoints.push({
            day: d,
            hour: 23,
            minute: 0,
            targetTemperature: exports.COOL,
        });
    }
    for (const d of [model_1.Day.Saturday, model_1.Day.Sunday]) {
        setPoints.push({
            day: d,
            hour: 9,
            minute: 0,
            targetTemperature: exports.WARM,
        });
        setPoints.push({
            day: d,
            hour: 23,
            minute: 30,
            targetTemperature: exports.COOL,
        });
    }
    return setPoints;
}
function utilitySchedule() {
    const setPoints = [];
    for (const d of [model_1.Day.Monday, model_1.Day.Tuesday, model_1.Day.Wednesday, model_1.Day.Thursday, model_1.Day.Friday]) {
        setPoints.push({
            day: d,
            hour: 17,
            minute: 0,
            targetTemperature: exports.INTERMEDIATE,
        });
        setPoints.push({
            day: d,
            hour: 23,
            minute: 0,
            targetTemperature: exports.COOL,
        });
    }
    for (const d of [model_1.Day.Saturday, model_1.Day.Sunday]) {
        setPoints.push({
            day: d,
            hour: 9,
            minute: 0,
            targetTemperature: exports.INTERMEDIATE,
        });
        setPoints.push({
            day: d,
            hour: 23,
            minute: 30,
            targetTemperature: exports.COOL,
        });
    }
    return setPoints;
}
// function chart(): ISetPoint[] {
//     const setPoints: ISetPoint[] = [];
//     for (const d of [Day.Monday, Day.Tuesday, Day.Wednesday, Day.Thursday, Day.Friday, Day.Saturday, Day.Sunday]) {
//         [0, 1, 2, 3, 4, 5, 6, 7].forEach(t => {
//             setPoints.push({
//                 day: d,
//                 hour: t * 3,
//                 minute: 0,
//                 targetTemperature: t + 16,
//             });
//         });
//     }
//     return setPoints;
// }
const bedSchedule = [1 /*, 2, 3, 4, 5, 6, 0*/].map((e) => ({ day: e, hour: 0, minute: 0, targetTemperature: 16 }));
exports.DEFAULT_HEATING_PLAN = [
    {
        id: "1",
        name: "Living Room",
        enabled: true,
        schedule: mainSchedule(),
        zones: ["Living Room"],
        overrides: {
            DayAtHome: {
                targetTemperature: 17,
            },
        },
    },
    {
        id: "2",
        name: "Bathroom",
        enabled: true,
        schedule: bathroomSchedule(),
        zones: ["Bathroom"],
        overrides: {
            DayAway: {
                targetTemperature: 17,
            },
        },
    },
    {
        id: "3",
        name: "Utility",
        enabled: true,
        schedule: utilitySchedule(),
        zones: ["Kitchen", "Study"],
        overrides: {
            Holiday: {
                targetTemperature: 17,
            },
        },
    },
    {
        id: "4",
        name: "Bedroom",
        enabled: true,
        schedule: bedSchedule,
        zones: ["Bedroom"],
        overrides: {
            Sleep: {
                targetTemperature: 17,
            },
        },
    },
    // {
    //     id: "5",
    //     name: "Chart",
    //     enabled: true,
    //     schedule: chart(),
    // },
];
exports.DEFAULT_HEATING_ZONES = [
    {
        id: "Bathroom",
        name: "Bathroom",
    },
    {
        id: "Bedroom",
        name: "Bedroom",
    },
    {
        id: "Kitchen",
        name: "Kitchen",
    },
    {
        id: "Living Room",
        name: "Living Room",
    },
    {
        id: "Study",
        name: "Study",
    },
];
exports.DEFAULT_HEATING_DEVICES = [
    {
        id: "Bad",
        name: "Bad",
    },
    {
        id: "Bett",
        name: "Bett",
    },
    {
        id: "Flur",
        name: "Flur",
    },
    {
        id: "Tür",
        name: "Tür",
    },
    {
        id: "Mitte",
        name: "Mitte",
    },
    {
        id: "Sofa",
        name: "Sofa",
    },
    {
        id: "Tisch",
        name: "Tisch",
    },
    {
        id: "Büro",
        name: "Büro",
    },
];


/***/ }),

/***/ "./src/app/helper/index.ts":
/*!*********************************!*\
  !*** ./src/app/helper/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./AsyncThrottle */ "./src/app/helper/AsyncThrottle.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./Mutex */ "./src/app/helper/Mutex.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./Retry */ "./src/app/helper/Retry.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./defaultPlan */ "./src/app/helper/defaultPlan.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./slotTime */ "./src/app/helper/slotTime.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./AsyncDebounce */ "./src/app/helper/AsyncDebounce.ts"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./synchronize */ "./src/app/helper/synchronize.ts"), exports);


/***/ }),

/***/ "./src/app/helper/slotTime.ts":
/*!************************************!*\
  !*** ./src/app/helper/slotTime.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


// tslint:disable: trailing-comma
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.slotTime = void 0;
/**
 * Normalizes the time to a given number of slots.
 *
 * @param minutes it
 * @param slots amount of slots in one hour
 */
function slotTime(minutes, slots = 4) {
    const a = 0;
    const b = Math.round(slots);
    //        (b-a)(x - min)
    // f(x) = -------------- +  a
    //        max - min
    //
    return Math.round(Math.floor((((b - a) * (minutes - 0)) /
        (59 - 0))
        + a) * (60 / b));
}
exports.slotTime = slotTime;


/***/ }),

/***/ "./src/app/helper/synchronize.ts":
/*!***************************************!*\
  !*** ./src/app/helper/synchronize.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.synchronize = void 0;
const Mutex_1 = __webpack_require__(/*! ./Mutex */ "./src/app/helper/Mutex.ts");
function Synchronize(mutex, func) {
    return function (...args) {
        // @ts-ignore
        const self = this;
        try {
            return mutex
                .lock()
                .then((unlock) => func
                .apply(self, args)
                .finally(() => unlock()));
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
}
/**
 * Synchronizes all calls to the given function
 * @param mutex If no mutex is given a new Mutex is created implicitly
 */
function synchronize(mutex) {
    if (mutex == null) {
        mutex = new Mutex_1.Mutex();
    }
    return (_target, _property, descriptor, ..._other) => {
        if (descriptor.value != null) {
            return Object.assign(Object.assign({}, descriptor), { 
                // @ts-ignore
                value: Synchronize.apply(this, [mutex, descriptor.value]) });
        }
        return Object.assign(Object.assign({}, descriptor), { 
            // we do not decorate the setter as this makes no sense here
            // set: Synchronize.apply(this, [mutex, descriptor.set]),
            // @ts-ignore
            get: Synchronize.apply(this, [mutex, descriptor.get]) });
    };
}
exports.synchronize = synchronize;


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "@app/model":
/*!*****************************!*\
  !*** external "@app/model" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("@app/model");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app/helper/index.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDBCQUEwQiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxrQkFBa0I7QUFDN0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pOQTs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nLy4vc3JjL2FwcC9oZWxwZXIvQXN5bmNEZWJvdW5jZS50cyIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nLy4vc3JjL2FwcC9oZWxwZXIvQXN5bmNUaHJvdHRsZS50cyIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nLy4vc3JjL2FwcC9oZWxwZXIvTXV0ZXgudHMiLCJ3ZWJwYWNrOi8vaG9tZXktaGVhdGluZy8uL3NyYy9hcHAvaGVscGVyL1JldHJ5LnRzIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvLi9zcmMvYXBwL2hlbHBlci9kZWZhdWx0UGxhbi50cyIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nLy4vc3JjL2FwcC9oZWxwZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vaG9tZXktaGVhdGluZy8uL3NyYy9hcHAvaGVscGVyL3Nsb3RUaW1lLnRzIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvLi9zcmMvYXBwL2hlbHBlci9zeW5jaHJvbml6ZS50cyIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nL2V4dGVybmFsIGNvbW1vbmpzMiBcIkBhcHAvbW9kZWxcIiIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9ob21leS1oZWF0aW5nL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaG9tZXktaGVhdGluZy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL2hvbWV5LWhlYXRpbmcvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgQW55QXJnc0Z1bmM8VD4gPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8VD47XG5cbi8qKlxuICogRGVib3VuY2VzIHRoZSBhc3luYyBmdW5jdGlvbiBieSBtc1xuICpcbiAqIEBwYXJhbSBmdW5jdGlvblRvRGVib3VuY2UgaXRcbiAqIEBwYXJhbSB3YWl0IGluIG1zXG4gKiBAcGFyYW0gbGVhZGluZyB0cnVlLCBpZiB5b3Ugd2FudCB0aGUgZmlyc3QgcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBc3luY0RlYm91bmNlPFQ+KGZ1bmN0aW9uVG9EZWJvdW5jZTogQW55QXJnc0Z1bmM8VD4sIHdhaXQ6IG51bWJlciwgbGVhZGluZyA9IGZhbHNlKTogQW55QXJnc0Z1bmM8VD4ge1xuICAgIGxldCByZXNvbHZlcnM6IGFueVtdID0gW107XG4gICAgbGV0IHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICAgIGxldCBsZWFkaW5nUmVzdWx0OiBhbnk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW5JbW1lZGlhdGVseSA9IGxlYWRpbmcgJiYgIXRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7IGNsZWFyVGltZW91dCh0aW1lb3V0KTsgfVxuXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBsZWFkaW5nID8gbGVhZGluZ1Jlc3VsdCA6IGZ1bmN0aW9uVG9EZWJvdW5jZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGZvciAocmVzb2x2ZSBvZiByZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmVycyA9IFtdO1xuICAgICAgICAgICAgfSwgd2FpdCkgYXMgdW5rbm93biBhcyBOb2RlSlMuVGltZW91dDtcblxuICAgICAgICAgICAgaWYgKHJ1bkltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxlYWRpbmdSZXN1bHQgPSBmdW5jdGlvblRvRGVib3VuY2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShsZWFkaW5nUmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4iLCJ0eXBlIEFueUFyZ3NGdW5jPFQ+ID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPFQ+O1xuXG4vKipcbiAqIFRocm90dGxlcyB0aGUgY2FsbCB0byB0aGUgYXN5bmMgZnVuY3Rpb24gdG8gbWF4Q2FsbHMgcGVyIGR1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jVG9UaHJvdHRsZSBUaGUgZnVuY3Rpb24gdG8gZXhjdXRlLlxuICogQHBhcmFtIGR1cmF0aW9uIGluIG1zXG4gKiBAcGFyYW0gbWF4Q2FsbHMgcGVyIGR1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBc3luY1Rocm90dGxlPFQ+KGZ1bmNUb1Rocm90dGxlOiBBbnlBcmdzRnVuYzxUPiwgZHVyYXRpb246IG51bWJlciwgbWF4Q2FsbHM6IG51bWJlciA9IDEpOiBBbnlBcmdzRnVuYzxUPiB7XG4gICAgbGV0IHByb2Nlc3NDb3VudCA9IDA7XG4gICAgbGV0IHRpY2tzID0gMDtcblxuICAgIC8vIHRocm90dGxlIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgaWYgKChub3cgLSB0aWNrcykgPiAxKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvdW50ID0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGlja3MgPSBub3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3NDb3VudCA8IG1heENhbGxzKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpY2tzICs9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NDb3VudCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyByZXNvbHZlKGZ1bmNUb1Rocm90dGxlLmFwcGx5KHRoaXMsIGFyZ3MpKTsgfSwgdGlja3MgLSBub3cpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuIiwidHlwZSBWb2lkRnVuY3Rpb24gPSAoKSA9PiB2b2lkO1xuXG4vKipcbiAqIE9ubHkgb25lIFRocmVhZCBjYW4gcnVsZSB0aGUgd29ybGQuXG4gKlxuICogY29uc3QgdW5sb2NrID0gYXdhaXQgbmV3IE11dGV4KCkubG9jaygpO1xuICoge1xuICogICAgICAvLyBjb2RlIHRoYXQgc2hvdWxkIHJ1biBsb2NrZWRcbiAqIH1cbiAqIHVubG9jaygpO1xuICovXG5leHBvcnQgY2xhc3MgTXV0ZXgge1xuICAgIHByaXZhdGUgbG9ja2luZzogUHJvbWlzZTxWb2lkRnVuY3Rpb24+O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZW1wdHlcbiAgICAgICAgdGhpcy5sb2NraW5nID0gUHJvbWlzZS5yZXNvbHZlKCgpOiB2b2lkID0+IHt9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbG9jaygpOiBQcm9taXNlPFZvaWRGdW5jdGlvbj4ge1xuICAgICAgICBsZXQgdW5sb2NrTmV4dDogVm9pZEZ1bmN0aW9uO1xuXG4gICAgICAgIGNvbnN0IHdpbGxMb2NrID0gbmV3IFByb21pc2U8Vm9pZEZ1bmN0aW9uPigocmVzb2x2ZSkgPT4gdW5sb2NrTmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgd2lsbFVubG9jayA9IHRoaXMubG9ja2luZy50aGVuKCgpID0+IHVubG9ja05leHQpO1xuICAgICAgICB0aGlzLmxvY2tpbmcgPSB0aGlzLmxvY2tpbmcudGhlbigoKSA9PiB3aWxsTG9jayk7XG5cbiAgICAgICAgcmV0dXJuIHdpbGxVbmxvY2s7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSUxvZ2dlciB9IGZyb20gXCJAYXBwL3NlcnZpY2VzXCI7XG5cbi8qKlxuICogUmV0cnkgdGhlIGFzeW5jIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIGNhbGwgdGhhdFxuICogQHBhcmFtIGxvZ2dlciBkdW1wIGVycm9ycyBoZXJlXG4gKiBAcGFyYW0gbWF4UmV0cmllcyBzbyBvZnRlblxuICogQHBhcmFtIHJldHJ5SW50ZXJ2YWwgd2FpdCB0aGlzIHRpbWUgaW4gbXNcbiAqIEBwYXJhbSBpbmNyZW1lbnRhbEJhY2tvZmYgZG91YmxlIHRoZSB0aW1lIG9uIGVhY2ggZXhlY3V0aW9uP1xuICogQHBhcmFtIG1heFJldHJ5SW50ZXJ2YWwgbWF4aW11bSBkdXJhdGlvbiBwZXIgY3ljbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJldHJ5PFQ+KGZ1bmM6ICgpID0+IFByb21pc2U8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyPzogSUxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZXRyaWVzID0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUludGVydmFsID0gMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRhbEJhY2tvZmYgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZXRyeUludGVydmFsID0gMTAwMDApOiBQcm9taXNlPFQ+IHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGNhbGwgdGhlIGZ1bmNcbiAgICAgICAgZnVuYygpXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLy8gaWYgaXQgZmFpbHNcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICE9IG51bGwpIHsgbG9nZ2VyLmRlYnVnKGBSZXRyeSBhY3Rpb24gJHttYXhSZXRyaWVzfSB0aW1lcywgd2FpdGluZyBmb3IgJHtyZXRyeUludGVydmFsfWAsIGVycm9yKTsgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChtYXhSZXRyaWVzIC0gMSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZWV4ZWN1dGUgYWZ0ZXIgcmV0cnlJbnRlcnZhbFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBvciBkb3VibGUgdGhlIHRpbWUgb24gaW5jcmVtZW50YWwgYmFja29mZlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW50ZXJ2YWwgPSBpbmNyZW1lbnRhbEJhY2tvZmYgPyBNYXRoLm1pbihtYXhSZXRyeUludGVydmFsLCByZXRyeUludGVydmFsICogMikgOiByZXRyeUludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5IG9uZSB0aW1lIGxlc3NcbiAgICAgICAgICAgICAgICAgICAgUmV0cnkoZnVuYywgbG9nZ2VyLCBtYXhSZXRyaWVzIC0gMSwgbmV4dEludGVydmFsLCBpbmNyZW1lbnRhbEJhY2tvZmYsIG1heFJldHJ5SW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0sIHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCJcbmltcG9ydCB7IERheSwgSUhlYXRpbmdEZXZpY2UsIElIZWF0aW5nUGxhbiwgSUhlYXRpbmdab25lLCBJU2V0UG9pbnQgfSBmcm9tIFwiQGFwcC9tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgV0FSTTogbnVtYmVyID0gMjAuNTtcbmV4cG9ydCBjb25zdCBJTlRFUk1FRElBVEU6IG51bWJlciA9IDE4LjU7XG5leHBvcnQgY29uc3QgQ09PTDogbnVtYmVyID0gMTY7XG5cbmZ1bmN0aW9uIGJhdGhyb29tU2NoZWR1bGUoKTogSVNldFBvaW50W10ge1xuICAgIGNvbnN0IHNldFBvaW50czogSVNldFBvaW50W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZCBvZiBbRGF5Lk1vbmRheSwgRGF5LlR1ZXNkYXksIERheS5XZWRuZXNkYXksIERheS5UaHVyc2RheSwgRGF5LkZyaWRheV0pIHtcbiAgICAgICAgc2V0UG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgZGF5OiBkLFxuICAgICAgICAgICAgaG91cjogNixcbiAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiBXQVJNLFxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiA5LFxuICAgICAgICAgICAgbWludXRlOiAwLFxuICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IENPT0wsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZCBvZiBbRGF5LlNhdHVyZGF5LCBEYXkuU3VuZGF5XSkge1xuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiA5LFxuICAgICAgICAgICAgbWludXRlOiAwLFxuICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IElOVEVSTUVESUFURSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0UG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgZGF5OiBkLFxuICAgICAgICAgICAgaG91cjogMjMsXG4gICAgICAgICAgICBtaW51dGU6IDMwLFxuICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IENPT0wsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRQb2ludHM7XG59XG5cbmZ1bmN0aW9uIG1haW5TY2hlZHVsZSgpOiBJU2V0UG9pbnRbXSB7XG4gICAgY29uc3Qgc2V0UG9pbnRzOiBJU2V0UG9pbnRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBkIG9mIFtEYXkuTW9uZGF5LCBEYXkuVHVlc2RheSwgRGF5LldlZG5lc2RheSwgRGF5LlRodXJzZGF5LCBEYXkuRnJpZGF5XSkge1xuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiAxNyxcbiAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiBJTlRFUk1FRElBVEUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRheTogZCxcbiAgICAgICAgICAgIGhvdXI6IDE4LFxuICAgICAgICAgICAgbWludXRlOiAzMCxcbiAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiBXQVJNLFxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiAyMyxcbiAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiBDT09MLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGQgb2YgW0RheS5TYXR1cmRheSwgRGF5LlN1bmRheV0pIHtcbiAgICAgICAgc2V0UG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgZGF5OiBkLFxuICAgICAgICAgICAgaG91cjogOSxcbiAgICAgICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiBXQVJNLFxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiAyMyxcbiAgICAgICAgICAgIG1pbnV0ZTogMzAsXG4gICAgICAgICAgICB0YXJnZXRUZW1wZXJhdHVyZTogQ09PTCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldFBvaW50cztcbn1cblxuZnVuY3Rpb24gdXRpbGl0eVNjaGVkdWxlKCk6IElTZXRQb2ludFtdIHtcbiAgICBjb25zdCBzZXRQb2ludHM6IElTZXRQb2ludFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGQgb2YgW0RheS5Nb25kYXksIERheS5UdWVzZGF5LCBEYXkuV2VkbmVzZGF5LCBEYXkuVGh1cnNkYXksIERheS5GcmlkYXldKSB7XG4gICAgICAgIHNldFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRheTogZCxcbiAgICAgICAgICAgIGhvdXI6IDE3LFxuICAgICAgICAgICAgbWludXRlOiAwLFxuICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IElOVEVSTUVESUFURSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0UG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgZGF5OiBkLFxuICAgICAgICAgICAgaG91cjogMjMsXG4gICAgICAgICAgICBtaW51dGU6IDAsXG4gICAgICAgICAgICB0YXJnZXRUZW1wZXJhdHVyZTogQ09PTCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBkIG9mIFtEYXkuU2F0dXJkYXksIERheS5TdW5kYXldKSB7XG4gICAgICAgIHNldFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRheTogZCxcbiAgICAgICAgICAgIGhvdXI6IDksXG4gICAgICAgICAgICBtaW51dGU6IDAsXG4gICAgICAgICAgICB0YXJnZXRUZW1wZXJhdHVyZTogSU5URVJNRURJQVRFLFxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRQb2ludHMucHVzaCh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBob3VyOiAyMyxcbiAgICAgICAgICAgIG1pbnV0ZTogMzAsXG4gICAgICAgICAgICB0YXJnZXRUZW1wZXJhdHVyZTogQ09PTCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldFBvaW50cztcbn1cblxuLy8gZnVuY3Rpb24gY2hhcnQoKTogSVNldFBvaW50W10ge1xuLy8gICAgIGNvbnN0IHNldFBvaW50czogSVNldFBvaW50W10gPSBbXTtcblxuLy8gICAgIGZvciAoY29uc3QgZCBvZiBbRGF5Lk1vbmRheSwgRGF5LlR1ZXNkYXksIERheS5XZWRuZXNkYXksIERheS5UaHVyc2RheSwgRGF5LkZyaWRheSwgRGF5LlNhdHVyZGF5LCBEYXkuU3VuZGF5XSkge1xuXG4vLyAgICAgICAgIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XS5mb3JFYWNoKHQgPT4ge1xuLy8gICAgICAgICAgICAgc2V0UG9pbnRzLnB1c2goe1xuLy8gICAgICAgICAgICAgICAgIGRheTogZCxcbi8vICAgICAgICAgICAgICAgICBob3VyOiB0ICogMyxcbi8vICAgICAgICAgICAgICAgICBtaW51dGU6IDAsXG4vLyAgICAgICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IHQgKyAxNixcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9XG5cbi8vICAgICByZXR1cm4gc2V0UG9pbnRzO1xuLy8gfVxuXG5jb25zdCBiZWRTY2hlZHVsZSA9IFsxLyosIDIsIDMsIDQsIDUsIDYsIDAqL10ubWFwKChlKSA9PiAoeyBkYXk6IGUsIGhvdXI6IDAsIG1pbnV0ZTogMCwgdGFyZ2V0VGVtcGVyYXR1cmU6IDE2IH0pKTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBVElOR19QTEFOOiBJSGVhdGluZ1BsYW5bXSA9IFtcbiAgICB7XG4gICAgICAgIGlkOiBcIjFcIixcbiAgICAgICAgbmFtZTogXCJMaXZpbmcgUm9vbVwiLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzY2hlZHVsZTogbWFpblNjaGVkdWxlKCksXG5cbiAgICAgICAgem9uZXM6IFtcIkxpdmluZyBSb29tXCJdLFxuICAgICAgICBvdmVycmlkZXM6IHtcbiAgICAgICAgICAgIERheUF0SG9tZToge1xuICAgICAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiAxNyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIjJcIixcbiAgICAgICAgbmFtZTogXCJCYXRocm9vbVwiLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzY2hlZHVsZTogYmF0aHJvb21TY2hlZHVsZSgpLFxuXG4gICAgICAgIHpvbmVzOiBbXCJCYXRocm9vbVwiXSxcbiAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICBEYXlBd2F5OiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IDE3LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IFwiM1wiLFxuICAgICAgICBuYW1lOiBcIlV0aWxpdHlcIixcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2NoZWR1bGU6IHV0aWxpdHlTY2hlZHVsZSgpLFxuXG4gICAgICAgIHpvbmVzOiBbXCJLaXRjaGVuXCIsIFwiU3R1ZHlcIl0sXG4gICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgSG9saWRheToge1xuICAgICAgICAgICAgICAgIHRhcmdldFRlbXBlcmF0dXJlOiAxNyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IFwiNFwiLFxuICAgICAgICBuYW1lOiBcIkJlZHJvb21cIixcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc2NoZWR1bGU6IGJlZFNjaGVkdWxlLFxuXG4gICAgICAgIHpvbmVzOiBbXCJCZWRyb29tXCJdLFxuICAgICAgICBvdmVycmlkZXM6IHtcbiAgICAgICAgICAgIFNsZWVwOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VGVtcGVyYXR1cmU6IDE3LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgLy8ge1xuICAgIC8vICAgICBpZDogXCI1XCIsXG4gICAgLy8gICAgIG5hbWU6IFwiQ2hhcnRcIixcbiAgICAvLyAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvLyAgICAgc2NoZWR1bGU6IGNoYXJ0KCksXG4gICAgLy8gfSxcbl07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQVRJTkdfWk9ORVM6IElIZWF0aW5nWm9uZVtdID0gW1xuICAgIHtcbiAgICAgICAgaWQ6IFwiQmF0aHJvb21cIixcbiAgICAgICAgbmFtZTogXCJCYXRocm9vbVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogXCJCZWRyb29tXCIsXG4gICAgICAgIG5hbWU6IFwiQmVkcm9vbVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogXCJLaXRjaGVuXCIsXG4gICAgICAgIG5hbWU6IFwiS2l0Y2hlblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogXCJMaXZpbmcgUm9vbVwiLFxuICAgICAgICBuYW1lOiBcIkxpdmluZyBSb29tXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIlN0dWR5XCIsXG4gICAgICAgIG5hbWU6IFwiU3R1ZHlcIixcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBVElOR19ERVZJQ0VTOiBJSGVhdGluZ0RldmljZVtdID0gW1xuICAgIHtcbiAgICAgICAgaWQ6IFwiQmFkXCIsXG4gICAgICAgIG5hbWU6IFwiQmFkXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIkJldHRcIixcbiAgICAgICAgbmFtZTogXCJCZXR0XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIkZsdXJcIixcbiAgICAgICAgbmFtZTogXCJGbHVyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIlTDvHJcIixcbiAgICAgICAgbmFtZTogXCJUw7xyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiBcIk1pdHRlXCIsXG4gICAgICAgIG5hbWU6IFwiTWl0dGVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IFwiU29mYVwiLFxuICAgICAgICBuYW1lOiBcIlNvZmFcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6IFwiVGlzY2hcIixcbiAgICAgICAgbmFtZTogXCJUaXNjaFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogXCJCw7xyb1wiLFxuICAgICAgICBuYW1lOiBcIkLDvHJvXCIsXG4gICAgfSxcbl07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9Bc3luY1Rocm90dGxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9NdXRleFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vUmV0cnlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RlZmF1bHRQbGFuXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zbG90VGltZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQXN5bmNEZWJvdW5jZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3luY2hyb25pemVcIjtcbiIsIi8vIHRzbGludDpkaXNhYmxlOiB0cmFpbGluZy1jb21tYVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRpbWUgdG8gYSBnaXZlbiBudW1iZXIgb2Ygc2xvdHMuXG4gKlxuICogQHBhcmFtIG1pbnV0ZXMgaXRcbiAqIEBwYXJhbSBzbG90cyBhbW91bnQgb2Ygc2xvdHMgaW4gb25lIGhvdXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsb3RUaW1lKG1pbnV0ZXM6IG51bWJlciwgc2xvdHMgPSA0KSB7XG4gICAgY29uc3QgYSA9IDA7XG4gICAgY29uc3QgYiA9IE1hdGgucm91bmQoc2xvdHMpO1xuXG4gICAgLy8gICAgICAgIChiLWEpKHggLSBtaW4pXG4gICAgLy8gZih4KSA9IC0tLS0tLS0tLS0tLS0tICsgIGFcbiAgICAvLyAgICAgICAgbWF4IC0gbWluXG4gICAgLy9cbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLmZsb29yKFxuICAgICAgICAoKChiIC0gYSkgKiAobWludXRlcyAtIDApKSAvXG4gICAgICAgICg1OSAtIDApKVxuICAgICAgICArIGFcbiAgICApICogKDYwIC8gYikpO1xufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tIFwiLi9NdXRleFwiO1xuXG50eXBlIEFueUZ1bmMgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PjtcblxuZnVuY3Rpb24gU3luY2hyb25pemUobXV0ZXg6IE11dGV4LCBmdW5jOiBBbnlGdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IGFueVtdKTogYW55IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG11dGV4XG4gICAgICAgICAgICAgICAgLmxvY2soKVxuICAgICAgICAgICAgICAgIC50aGVuKCh1bmxvY2spID0+IGZ1bmNcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5KHNlbGYsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHVubG9jaygpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogU3luY2hyb25pemVzIGFsbCBjYWxscyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAqIEBwYXJhbSBtdXRleCBJZiBubyBtdXRleCBpcyBnaXZlbiBhIG5ldyBNdXRleCBpcyBjcmVhdGVkIGltcGxpY2l0bHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN5bmNocm9uaXplKG11dGV4PzogTXV0ZXgpIHtcbiAgICBpZiAobXV0ZXggPT0gbnVsbCkgeyBtdXRleCA9IG5ldyBNdXRleCgpOyB9XG5cbiAgICByZXR1cm4gKF90YXJnZXQ6IGFueSwgX3Byb3BlcnR5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvciwgLi4uX290aGVyOiBhbnlbXSkgPT4ge1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZGVzY3JpcHRvcixcblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2YWx1ZTogU3luY2hyb25pemUuYXBwbHkodGhpcywgW211dGV4LCBkZXNjcmlwdG9yLnZhbHVlXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlc2NyaXB0b3IsXG5cbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBkZWNvcmF0ZSB0aGUgc2V0dGVyIGFzIHRoaXMgbWFrZXMgbm8gc2Vuc2UgaGVyZVxuICAgICAgICAgICAgLy8gc2V0OiBTeW5jaHJvbml6ZS5hcHBseSh0aGlzLCBbbXV0ZXgsIGRlc2NyaXB0b3Iuc2V0XSksXG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGdldDogU3luY2hyb25pemUuYXBwbHkodGhpcywgW211dGV4LCBkZXNjcmlwdG9yLmdldF0pLFxuICAgICAgICB9O1xuICAgIH07XG59XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAYXBwL21vZGVsXCIpOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvYXBwL2hlbHBlci9pbmRleC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==