/* eslint-disable new-cap */
/* eslint-disable max-classes-per-file */
/* eslint-disable global-require */
/* eslint-disable import/no-dynamic-require */

'use strict';

// const path = require('path');

const Util = require('./Util');
const APIError = require('./APIError');

class API {

  static SPECIFICATION = null;
  static SPECIFICATION_URL = null;
  static DEFINITION_CLASSES = {};

  static JSDOC_PARAMS = null;
  static JSDOC_DESCRIPTION = null;
  static JSDOC_PRIVATE = null;
  static JSDOC_EXAMPLE = null;

  constructor({
    baseUrl,
    debug = false,
    secret = null,
  } = {}) {
    // Set Debug Enabled
    const debugEnvKey = `${Util.envKey(this.constructor.name)}_DEBUG`;
    const debugEnv = Util.env(debugEnvKey);

    Object.defineProperty(this, '__debugEnabled', {
      value: debugEnv !== null
        ? !!debugEnv
        : !!debug,
      enumerable: false,
      writable: true,
    });

    // Set Secret
    const secretEnvKey = `${Util.envKey(this.constructor.name)}_SECRET`;
    const secretEnv = Util.env(secretEnvKey);

    Object.defineProperty(this, '__secret', {
      value: secretEnv !== null
        ? secretEnv
        : secret,
      enumerable: false,
      writable: false,
    });

    // Set Base URL
    const baseUrlEnvKey = `${Util.envKey(this.constructor.name)}_BASEURL`;
    const baseUrlEnv = Util.env(baseUrlEnvKey);

    this.baseUrl = baseUrlEnv || baseUrl || `https://${this.constructor.SPECIFICATION.host}${this.constructor.SPECIFICATION.basePath}`;
    if (this.baseUrl.endsWith('/')) this.baseUrl = this.baseUrl.substring(0, this.baseUrl.length - 1);

    // Create Operations
    for (const [operationId, operation] of Object.entries(this.constructor.SPECIFICATION.operations || {})) {
      this.__registerOperation(operationId, operation);
    }
  }

  __registerOperation(operationId, operation) {
    if (this[operationId]) return;

    this[operationId] = async ({
      $validate = true,
      $timeout = 10000,
      $timeoutMessage = null,
      $body = {},
      $query = {},
      $headers = {},
      ...args
    } = {}) => {
      let pathWithParameters = operation.path;
      let body = { ...$body };
      const query = { ...$query };
      const headers = { ...$headers };

      // Parse Parameters
      Object.entries(operation.parameters || {}).forEach(([parameterId, parameter]) => {
        let value = args[parameterId];

        // Set secret if not provided as parameter but in constructor
        if (parameterId === 'secret' && typeof value === 'undefined' && typeof this.__secret === 'string') {
          value = this.__secret;
        }

        // Validate the parameter
        if ($validate) {
          if (parameter.required === true && typeof value === 'undefined') {
            throw new Error(`Missing Parameter: ${parameterId}`);
          }

          if (typeof value !== 'undefined') {
            if (parameter.type === 'string' && typeof value !== 'string') {
              throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
            }

            if (parameter.type === 'number' && typeof value !== 'number') {
              throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: number`);
            }

            if (parameter.type === 'boolean' && typeof value !== 'boolean') {
              throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: boolean`);
            }
          }
        }

        // Set the parameter
        if (typeof value !== 'undefined') {
          switch (parameter.in) {
            case 'path': {
              pathWithParameters = pathWithParameters.replace(`{${parameterId}}`, value);
              break;
            }
            case 'query': {
              query[parameterId] = value;
              break;
            }
            case 'body': {
              if (parameter.unpack) {
                body = {
                  ...body,
                  ...value,
                };
              } else {
                body[parameterId] = value;
              }
              break;
            }
            default: {
              throw new Error(`Invalid 'in': ${parameter.in}`);
            }
          }
        }
      });

      return this.call({
        method: operation.method,
        headers,
        query,
        body,
        path: pathWithParameters,
        context: { operation },
        timeout: $timeout,
        timeoutMessage: $timeoutMessage,
      }).catch(err => {
        if (typeof this.__secret === 'string' && err.message.includes(this.__secret)) {
          err.message = err.message.replace(this.__secret, '<redacted>');
        }

        throw err;
      });
    };
  }

  __debug(...props) {
    if (!this.__debugEnabled) return;
    // eslint-disable-next-line no-console
    console.log('[homey-api]', `[${this.constructor.name}]`, ...props);
  }

  async call(request) {
    // Parse Request
    request = await this.onCallRequestPrepare({ request });

    // Parse Response
    let response = await this.onCallRequestExecute({ request });
    response = await this.onCallResponse({ request, response });

    // Return Response
    return response;
  }

  async onCallRequestPrepare({ request }) {
    // Context
    request.context = {
      ...request.context,
    };

    // Method
    request.method = String(request.method).toUpperCase();

    // Headers
    request.headers = {
      ...request.headers,
      ...await this.onCallRequestHeaders({ request }),
    };

    // Timeout
    request.timeout = request.timeout || 10000;
    request.timeoutMessage = request.timeoutMessage || `Timeout after ${request.timeout}ms`;

    // URL
    request.url = `${this.baseUrl}${request.path}`;

    if (request.query) {
      if (Object.keys(request.query).length) {
        request.url += `?${Util.stringifyQuery(request.query)}`;
      }
    }

    // Body
    if (['PUT', 'POST', 'DELETE'].includes(request.method)) {
      if (request.body && request.bodyJSON !== false) {
        request.headers['Content-Type'] = 'application/json';

        // Set bodyModified because when retrying this call,
        // we don't want to stringify twice.
        if (!request.bodyModified) {
          request.body = JSON.stringify(request.body);
          request.bodyModified = true;
        }

        delete request.bodyJSON;
      }
    } else {
      delete request.body;
    }

    return request;
  }

  async onCallRequestExecute({ request }) {
    this.__debug('onCallRequestExecute', request);

    return Util.timeout(Util.fetch(request.url, {
      method: request.method,
      headers: request.headers,
      body: request.body,
    }), request.timeout, request.timeoutMessage);
  }

  async onCallResponse({ request, response }) {
    const statusCode = response.status;
    const { statusText } = response;
    const responseOK = response.ok;

    // If HTTP 204 No Content
    if (statusCode === 204) return undefined;

    // Fetch body
    const body = await this.onCallResponseParseBody({
      request,
      response,
    });

    // If HTTP 200 - 300
    if (responseOK) {
      return this.onCallResponseOK({
        request,
        body,
        statusCode,
        statusText,
      });
    }

    // If HTTP 400 - 500
    return this.onCallResponseNotOK({
      request,
      body,
      statusCode,
      statusText,
    });
  }

  async onCallRequestHeaders({ request }) {
    return {};
  }

  async onCallResponseParseBody({ response }) {
    const responseContentType = response.headers.get('Content-Type');
    const responseText = await response.text();

    if (responseContentType && responseContentType.toLowerCase().includes('application/json')) {
      try {
        return JSON.parse(responseText);
      } catch (err) {
        throw new Error(`Failed to parse response body as JSON: ${err.message}`);
      }
    }

    return responseText;
  }

  async onCallResponseOK({
    context,
    body,
    statusCode,
    statusText,
  }) {
    return body;
  }

  async onCallResponseNotOK({
    context,
    body,
    statusCode,
    statusText,
  }) {
    this.__debug('Error:', body);

    let message = statusText;

    if (typeof body.error_description === 'string') {
      message = body.error_description;
    } else if (typeof body.error_message === 'string') {
      message = body.error_message;
    } else if (typeof body.error === 'string') {
      message = body.error;
    } else if (typeof body.message === 'string') {
      message = body.message;
    }

    throw new APIError(message, statusCode);
  }

}

module.exports = API;
