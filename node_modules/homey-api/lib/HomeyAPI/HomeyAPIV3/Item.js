'use strict';

const EventEmitter = require('../../EventEmitter');

class Item extends EventEmitter {

  static ID = null; // Set by Manager.js

  constructor({
    id,
    homey,
    manager,
    properties,
  }) {
    super();

    // Set ID
    Object.defineProperty(this, 'id', {
      value: id,
      enumerable: true,
      writable: false,
    });

    // Set Homey
    Object.defineProperty(this, 'homey', {
      value: homey,
      enumerable: false,
      writable: false,
    });

    // Set Manager
    Object.defineProperty(this, 'manager', {
      value: manager,
      enumerable: false,
      writable: false,
    });

    // Set Connected
    Object.defineProperty(this, '__connected', {
      value: false,
      enumerable: false,
      writable: true,
    });

    // Set Properties
    for (const [key, value] of Object.entries(properties)) {
      if (key === 'id') continue;

      Object.defineProperty(this, key, {
        value,
        enumerable: true,
        writable: true,
      });
    }
  }

  get uri() {
    return `homey:${this.constructor.ID}:${this.id}`;
  }

  __debug(...props) {
    this.manager.__debug(`[${this.constructor.name}:${this.id}]`, ...props);
  }

  __update(properties) {
    for (const [key, value] of Object.entries(properties)) {
      if (key === 'id') continue;

      this[key] = value;
    }

    this.emit('update', properties);
  }

  __delete() {
    this.destroy();
    this.emit('delete');
  }

  async connect() {
    this.__debug('connect');

    // If disconnecting, await that first
    try {
      // Ensure all microtasks are done first. E.g. if disconnect is called in the same tick as
      // connect. This way the disconnect is always started first so we can await the disconnect
      // promise before we try to connect again.
      await Promise.resolve();
      await this.__disconnectPromise;
    } catch (err) { }

    this.__connectPromise = Promise.resolve().then(async () => {
      if (!this.io) {
        this.io = this.homey.subscribe(this.uri, {
          onConnect: () => {
            this.__debug('onConnect');
            this.__connected = true;

            this.onConnect();
          },
          onDisconnect: () => {
            this.__debug('onDisconnect');
            this.__connected = false;

            this.onDisconnect();
          },
          onReconnect: () => {
            this.__debug('onDisconnect');

            this.onReconnect();
          },
          onEvent: (event, data) => {
            this.__debug('onEvent', event, data);

            this.emit(event, data);
          },
        });
      }

      await this.io;
    });

    // Delete the connecting Promise
    this.__connectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__connectPromise;
      });

    await this.__connectPromise;
  }

  async disconnect() {
    this.__debug('disconnect');

    // If connecting, await that first
    try {
      await this.__connectPromise;
    } catch (err) { }

    this.__disconnectPromise = Promise.resolve().then(async () => {
      this.__connected = false;

      if (this.io) {
        this.io
          .then(io => io.unsubscribe())
          .catch(err => this.__debug('Error Disconnecting:', err));
      }
    });

    // Delete the disconnecting Promise
    this.__disconnectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__disconnectPromise;
        // Delete this.io so connect can start new connections.
        delete this.io;
      });

    await this.__disconnectPromise;
  }

  onConnect() {
    // Overload Me
  }

  onReconnect() {
    // Overload Me
  }

  onDisconnect() {
    // Overload Me
  }

  destroy() {
    // Remove all event listeners
    this.removeAllListeners();

    // Disconnect from Socket.io
    this.disconnect().catch(() => { });
  }

  static transformGet(item) {
    return item;
  }

  static transformSet(item) {
    return item;
  }

}

module.exports = Item;
