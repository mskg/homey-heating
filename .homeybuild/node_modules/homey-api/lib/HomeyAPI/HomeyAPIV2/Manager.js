/* eslint-disable no-multi-assign */

'use strict';

const EventEmitter = require('../../EventEmitter');
const Util = require('../../Util');
const HomeyAPIError = require('../HomeyAPIError');
const Item = require('./Item');

/**
 * @class
 * @hideconstructor
 * @memberof HomeyAPIV2
 */
class Manager extends EventEmitter {

  static ITEMS = {};

  constructor({
    id,
    name,
    homey,
    items,
    operations,
  }) {
    super();

    // Set Homey
    Object.defineProperty(this, 'homey', {
      value: homey,
      enumerable: false,
      writable: false,
    });

    // Set ID
    Object.defineProperty(this, 'id', {
      value: id,
      enumerable: false,
      writable: false,
    });

    // Set URI
    Object.defineProperty(this, 'uri', {
      value: `homey:manager:${id}`,
      enumerable: false,
      writable: false,
    });

    // Set Name
    Object.defineProperty(this, 'name', {
      value: name,
      enumerable: false,
      writable: false,
    });

    // Set Connected
    Object.defineProperty(this, '__connected', {
      value: false,
      enumerable: false,
      writable: true,
    });

    // Set Items
    Object.defineProperty(this, '__items', {
      value: items,
      enumerable: false,
      writable: false,
    });
    Object.defineProperty(this, '__itemsById', {
      value: Object.entries(items).reduce((obj, [itemName, item]) => ({
        [item.id]: {
          name: itemName,
          ...item,
        },
        ...obj,
      }), {}),
      enumerable: false,
      writable: false,
    });

    // Set Cache
    Object.defineProperty(this, '__cache', {
      value: {},
      enumerable: false,
      writable: false,
    });

    Object.defineProperty(this, '__cacheAllComplete', {
      value: {},
      enumerable: false,
      writable: false,
    });

    // Prepare caches
    for (const { id } of Object.values(items)) {
      this.__cache[id] = {};
      this.__cacheAllComplete[id] = false;
    }

    // Create methods
    for (const [operationId, operation] of Object.entries(operations)) {
      Object.defineProperty(this,
        // Name method __super__foo if there's an override method
        this[operationId]
          ? `__super__${operationId}`
          : operationId,
        {
          value: async ({
            $validate = true,
            $cache = true,
            $timeout = 5000,
            $socket = true,
            $body = {},
            $query = {},
            $headers = {},
            ...args
          } = {}) => {
            let { path } = operation;
            let body = { ...$body };
            const query = { ...$query };
            const headers = { ...$headers };

            // Verify & Transform parameters
            if (operation.parameters) {
              // Parse Parameters
              for (const [parameterId, parameter] of Object.entries(operation.parameters)) {
                const value = args[parameterId];

                // Validate the parameter
                if ($validate) {
                  if (parameter.required === true && typeof value === 'undefined') {
                    throw new Error(`Missing Parameter: ${parameterId}`);
                  }

                  if (typeof value !== 'undefined') {
                    if (parameter.type === 'string' && typeof value !== 'string') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                    }

                    if (parameter.type === 'number' && typeof value !== 'number') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: number`);
                    }

                    if (parameter.type === 'boolean' && typeof value !== 'boolean') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: boolean`);
                    }

                    if (parameter.type === 'object' && typeof value !== 'object') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: object`);
                    }

                    if (parameter.type === 'array' && !Array.isArray(value)) {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: array`);
                    }

                    if (Array.isArray(parameter.type)) {
                      // TODO
                    }
                  }
                }

                // Set the parameter
                if (typeof value !== 'undefined') {
                  switch (parameter.in) {
                    case 'path': {
                      if (typeof value !== 'string') {
                        throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                      }

                      path = path.replace(`:${parameterId}`, value);
                      break;
                    }
                    case 'body': {
                      if (parameter.root) {
                        body = value;
                      } else {
                        body[parameterId] = value;
                      }
                      break;
                    }
                    case 'query': {
                      if (typeof value !== 'string') {
                        throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                      }

                      query[parameterId] = value;
                      break;
                    }
                    default: {
                      throw new Error(`Invalid 'in': ${parameter.in}`);
                    }
                  }
                }
              }
            }

            // Append query to path
            if (Object.keys(query).length > 0) {
              const queryString = Object.entries(query).map(([key, value]) => {
                return `${key}=${encodeURIComponent(value)}`;
              }).join('&');
              path = `${path}?${queryString}`;
            }

            let result;
            const benchmark = Util.benchmark();

            // If connected to Socket.io,
            // try to get the CRUD Item from Cache.
            if (this.isConnected() && operation.crud && $cache === true) {
              const itemId = items[operation.crud.item].id;
              const itemType = items[operation.crud.item].type || 'id';

              switch (operation.crud.type) {
                case 'getOne': {
                  const key = (itemType === 'filter')
                    ? `${args.uri}:${args.id}`
                    : `${args.id}`;

                  if (this.__cache[itemId][key]) {
                    this.__debug(`Serving ${itemId}:${key} from cache`);
                    return this.__cache[itemId][key];
                  }

                  break;
                }
                case 'getAll': {
                  // If array (uri + id)
                  if (this.__cache[itemId]
                    && this.__cacheAllComplete[itemId]
                    && itemType === 'filter') {
                    this.__debug(`Serving ${itemId}:all from cache`);
                    return Object.values(this.__cache[itemId]);
                  }

                  // If object (id)
                  if (this.__cache[itemId]
                    && this.__cacheAllComplete[itemId]) {
                    this.__debug(`Serving ${itemId}:all from cache`);
                    return this.__cache[itemId];
                  }
                  break;
                }
                default:
                  break;
              }
            }

            // If Homey is connected to Socket.io,
            // send the API request to socket.io.
            // This is about ~2x faster than HTTP
            if (this.homey.isConnected() && $socket === true) {
              result = await Util.timeout(new Promise((resolve, reject) => {
                this.homey.__ioNamespace.emit('api', {
                  args,
                  operation: operationId,
                  uri: this.uri,
                }, (err, result) => {
                  // String Error
                  if (typeof err === 'string') {
                    err = new HomeyAPIError({
                      error: err,
                    }, 500);
                    return reject(err);
                  }

                  // Object Error
                  if (typeof err === 'object' && err !== null) {
                    err = new HomeyAPIError({
                      stack: err.stack,
                      error: err.error,
                      error_description: err.error_description,
                    }, err.statusCode || 500);
                    return reject(err);
                  }

                  return resolve(result);
                });
              }), $timeout);
            } else {
              // Get from HTTP
              result = await this.homey.call({
                $timeout,
                headers,
                body,
                path: `/api/manager/${this.id}${path}`,
                method: operation.method,
              });
            }

            // Transform and cache output if this is a CRUD call
            if (operation.crud) {
              const itemId = items[operation.crud.item].id;
              const itemType = items[operation.crud.item].type || 'id';
              const ItemClass = this.constructor.ITEMS[itemId] || Item;
              const getItemKey = props => {
                if (itemType === 'filter') return `${props.uri}:${props.id}`;
                if (itemType === 'id') return props.id;
                throw new Error('Invalid Item Type');
              };
              const getItemUri = props => {
                if (itemType === 'filter') return null;
                if (itemType === 'id') return `homey:${itemId}:${props.id}`;
                throw new Error('Invalid Item Type');
              };

              switch (operation.crud.type) {
                case 'getOne': {
                  const key = getItemKey(result);
                  const uri = getItemUri(result);

                  result = new ItemClass({
                    key,
                    uri,
                    homey: this.homey,
                    manager: this,
                    properties: { ...result },
                  });

                  if (this.isConnected()) {
                    this.__cache[itemId][key] = result;
                  }

                  break;
                }
                case 'getAll': {
                  // Add all to cache
                  const currentKeys = {};
                  for (const [resultKey, item] of Object.entries(result)) {
                    const key = getItemKey(item);
                    const uri = getItemUri(item);
                    currentKeys[key] = true;

                    if (this.__cache[itemId][key]) {
                      result[resultKey] = this.__cache[itemId][key].__update(item);
                    } else {
                      result[resultKey] = new ItemClass({
                        key,
                        uri,
                        homey: this.homey,
                        manager: this,
                        properties: { ...item },
                      });

                      if (this.isConnected()) {
                        this.__cache[itemId][key] = result[resultKey];
                      }
                    }
                  }

                  // Find and delete deleted items from cache
                  if (this.__cache[itemId]) {
                    for (const cachedItem of Object.values(this.__cache[itemId])) {
                      const key = getItemKey(cachedItem);

                      if (!currentKeys[key]) {
                        delete this.__cache[itemId][key];
                      }
                    }
                  }

                  if (this.isConnected()) {
                    // Mark cache as complete
                    this.__cacheAllComplete[itemId] = true;
                  }

                  break;
                }
                case 'createOne':
                case 'updateOne': {
                  const key = getItemKey(result);
                  const uri = getItemUri(result);

                  if (this.__cache[itemId][key]) {
                    result = this.__cache[itemId][key].__update(result);
                  } else {
                    result = new ItemClass({
                      key,
                      uri,
                      homey: this.homey,
                      manager: this,
                      properties: result,
                    });

                    if (this.isConnected()) {
                      this.__cache[itemId][key] = result;
                    }
                  }
                  break;
                }
                case 'deleteOne': {
                  const key = getItemKey(args);

                  if (this.__cache[itemId][key]) {
                    this.__cache[itemId][key].destroy();
                    delete this.__cache[itemId][key];
                  }
                  result = null;
                  break;
                }
                default:
                  break;
              }
            }

            this.__debug(`${operationId} took ${benchmark()}ms`);
            return result;
          },
        });
    }
  }

  __debug(...props) {
    this.homey.__debug(`[${this.name}]`, ...props);
  }

  /**
   * If this manager's namespace is connected to Socket.io.
   * @returns {Boolean}
   */
  isConnected() {
    return this.__connected === true;
  }

  /**
   * Connect to the realtime namespace.
   * @returns {Promise<void>}
   */
  async connect() {
    this.__debug('connect');

    // If disconnecting, await that first
    try {
      await this.__disconnectPromise;
    } catch (err) { }

    this.__connectPromise = Promise.resolve().then(async () => {
      if (!this.io) {
        this.io = this.homey.subscribe(this.uri, {
          onConnect: () => {
            this.__debug('onConnect');
            this.__connected = true;
          },
          onDisconnect: reason => {
            this.__debug(`onDisconnect Reason:${reason}`);
            this.__connected = false;

            // Clear CRUD Item cache
            for (const itemId of Object.keys(this.__cache)) {
              this.__cache[itemId] = {};
              this.__cacheAllComplete[itemId] = false;
            }
          },
          onEvent: (event, data) => {
            this.__debug('onEvent', event);

            // Transform & add to cache if this is a CRUD event
            if (event.endsWith('.create')
              || event.endsWith('.update')
              || event.endsWith('.delete')) {
              const [itemId, operation] = event.split('.');
              const ItemClass = this.constructor.ITEMS[itemId] || Item;
              const itemType = this.__itemsById[itemId].type || 'id';
              const key = itemType === 'filter'
                ? `${data.uri}:${data.id}`
                : `${data.id}`;
              const uri = itemType === 'filter'
                ? null
                : `homey:${itemId}:${data.id}`;

              switch (operation) {
                case 'create': {
                  this.__cache[itemId][key] = new ItemClass({
                    key,
                    uri,
                    homey: this.homey,
                    manager: this,
                    properties: { ...data },
                  });
                  this.__cache[itemId][key].emit('create', data);

                  data = this.__cache[itemId][key];

                  break;
                }
                case 'update': {
                  if (this.__cache[itemId][key]) {
                    this.__cache[itemId][key].__update(data);
                    this.__cache[itemId][key].emit('update', data);
                  } else {
                    this.__cache[itemId][key] = new ItemClass({
                      key,
                      uri,
                      homey: this.homey,
                      manager: this,
                      properties: { ...data },
                    });
                  }

                  data = this.__cache[itemId][key];

                  break;
                }
                case 'delete': {
                  if (this.__cache[itemId][key]) {
                    this.__cache[itemId][key].emit('delete');
                    this.__cache[itemId][key].destroy();
                    delete this.__cache[itemId][key];
                  }
                  break;
                }
                default:
                  break;
              }
            }

            // Fire event listeners
            this.emit(event, data);
          },
        });
      }

      await this.io;
    });

    // Delete the connecting Promise
    this.__connectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__connectPromise;
      });

    await this.__connectPromise;
  }

  /**
   * Disconnect from the realtime namespace.
   * @returns {Promise<void>}
   */
  async disconnect() {
    this.__debug('disconnect');

    // If connecting, await that first
    try {
      await this.__connectPromise;
    } catch (err) { }

    this.__disconnectPromise = Promise.resolve().then(async () => {
      this.__connected = false;

      if (this.io) {
        await this.io
          .then(io => io.unsubscribe())
          .catch(err => this.__debug('Error Disconnecting:', err));

        delete this.io;
      }
    });

    // Delete the disconnecting Promise
    this.__disconnectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__disconnectPromise;
      });

    await this.__disconnectPromise;
  }

  destroy() {
    // Clear cache
    for (const id of Object.keys(this.__cache)) {
      this.__cache[id] = {};
    }

    for (const id of Object.keys(this.__cacheAllComplete)) {
      this.__cacheAllComplete[id] = false;
    }

    // Remove all event listeners
    this.removeAllListeners();

    // Disconnect from Socket.io
    this.disconnect().catch(() => { });
  }

}

module.exports = Manager;
