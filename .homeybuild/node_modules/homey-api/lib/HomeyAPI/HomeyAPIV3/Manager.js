/* eslint-disable no-multi-assign */

'use strict';

const EventEmitter = require('../../EventEmitter');
const Util = require('../../Util');
const HomeyAPIError = require('../HomeyAPIError');

// eslint-disable-next-line no-unused-vars
const Item = require('./Item');

/**
 * @class
 * @hideconstructor
 * @memberof HomeyAPIV3
 */
class Manager extends EventEmitter {

  static ID = null; // Set by HomeyAPIV3.js
  static CRUD = {};

  constructor({
    homey,
    items,
    operations,
  }) {
    super();

    // Set Homey
    Object.defineProperty(this, 'homey', {
      value: homey,
      enumerable: false,
      writable: false,
    });

    // Set Items
    Object.defineProperty(this, 'items', {
      value: Object.entries(items).reduce((obj, [itemName, item]) => {
        const ItemClass = this.constructor.CRUD[itemName]
          ? this.constructor.CRUD[itemName]
          // eslint-disable-next-line no-eval
          : eval(`(class ${itemName} extends Item {})`);
        ItemClass.ID = item.id;
        obj[item.id] = ItemClass;

        return obj;
      }, {}),
      enumerable: false,
      writable: false,
    });

    // Set Connected
    Object.defineProperty(this, '__connected', {
      value: false,
      enumerable: false,
      writable: true,
    });

    // Set Cache
    Object.defineProperty(this, '__cache', {
      value: Object.values(items).reduce((obj, item) => ({
        ...obj,
        [item.id]: {},
      }), {}),
      enumerable: false,
      writable: false,
    });

    Object.defineProperty(this, '__cacheAllComplete', {
      value: Object.values(items).reduce((obj, item) => ({
        ...obj,
        [item.id]: false,
      }), {}),
      enumerable: false,
      writable: false,
    });

    // Create methods
    for (const [operationId, operation] of Object.entries(operations)) {
      Object.defineProperty(this,
        // Name method __super__foo if there's an override method
        this[operationId]
          ? `__super__${operationId}`
          : operationId,
        {
          value: async ({
            $validate = true,
            $cache = true,
            $timeout = operation.timeout ?? 5000,
            $socket = operation.socket ?? true,
            $body = {},
            $query = {},
            $headers = {},
            ...args
          } = {}) => {
            let { path } = operation;
            let body = { ...$body };
            const query = { ...$query };
            const headers = { ...$headers };

            // Verify & Transform parameters
            if (operation.parameters) {
              // Parse Parameters
              for (const [parameterId, parameter] of Object.entries(operation.parameters)) {
                const value = args[parameterId];

                // Validate the parameter
                if ($validate) {
                  if (parameter.required === true && typeof value === 'undefined') {
                    throw new Error(`Missing Parameter: ${parameterId}`);
                  }

                  if (typeof value !== 'undefined') {
                    if (parameter.type === 'string' && typeof value !== 'string') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                    }

                    if (parameter.type === 'number' && typeof value !== 'number') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: number`);
                    }

                    if (parameter.type === 'boolean' && typeof value !== 'boolean') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: boolean`);
                    }

                    if (parameter.type === 'object' && typeof value !== 'object') {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: object`);
                    }

                    if (parameter.type === 'array' && !Array.isArray(value)) {
                      throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: array`);
                    }

                    if (Array.isArray(parameter.type)) {
                      // TODO
                    }
                  }
                }

                // Set the parameter
                if (typeof value !== 'undefined') {
                  switch (parameter.in) {
                    case 'path': {
                      if (typeof value !== 'string') {
                        throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                      }

                      path = path.replace(`:${parameterId}`, value);
                      break;
                    }
                    case 'body': {
                      if (parameter.root) {
                        body = value;
                      } else {
                        body[parameterId] = value;
                      }
                      break;
                    }
                    case 'query': {
                      if (typeof value !== 'string') {
                        throw new Error(`Invalid Parameter Type: ${parameterId}. Got: ${typeof value}. Expected: string`);
                      }

                      query[parameterId] = value;
                      break;
                    }
                    default: {
                      throw new Error(`Invalid 'in': ${parameter.in}`);
                    }
                  }
                }
              }
            }

            // Append query to path
            if (Object.keys(query).length > 0) {
              const queryString = Object.entries(query).map(([key, value]) => {
                return `${key}=${encodeURIComponent(value)}`;
              }).join('&');
              path = `${path}?${queryString}`;
            }

            let result;
            const benchmark = Util.benchmark();

            // If connected to Socket.io,
            // try to get the CRUD Item from Cache.
            if (this.isConnected() && operation.crud && $cache === true) {
              const itemId = items[operation.crud.item].id;

              switch (operation.crud.type) {
                case 'getOne': {
                  if (this.__cache[itemId][args.id]) {
                    return this.__cache[itemId][args.id];
                  }

                  break;
                }
                case 'getAll': {
                  if (this.__cache[itemId]
                    && this.__cacheAllComplete[itemId]) {
                    return this.__cache[itemId];
                  }
                  break;
                }
                default:
                  break;
              }
            }

            // If Homey is connected to Socket.io,
            // send the API request to socket.io.
            // This is about ~2x faster than HTTP
            if (this.homey.isConnected() && $socket === true) {
              result = await Util.timeout(new Promise((resolve, reject) => {
                this.__debug(`IO ${operationId}`);
                this.homey.__ioNamespace.emit('api', {
                  args,
                  operation: operationId,
                  uri: this.uri,
                }, (err, result) => {
                  // String Error
                  if (typeof err === 'string') {
                    err = new HomeyAPIError({
                      error: err,
                    }, 500);
                    return reject(err);
                  }

                  // Object Error
                  if (typeof err === 'object' && err !== null) {
                    err = new HomeyAPIError({
                      stack: err.stack,
                      error: err.error,
                      error_description: err.error_description,
                    }, err.statusCode || 500);
                    return reject(err);
                  }

                  return resolve(result);
                });
              }), $timeout);
            } else {
              // Get from HTTP
              result = await this.homey.call({
                $timeout,
                headers,
                body,
                path: `/api/manager/${this.constructor.ID}${path}`,
                method: operation.method,
              });
            }

            // Transform and cache output if this is a CRUD call
            if (operation.crud) {
              const itemId = items[operation.crud.item].id;
              const Item = this.items[itemId];

              switch (operation.crud.type) {
                case 'getOne': {
                  let item = { ...result };
                  item = Item.transformGet(item);
                  item = new Item({
                    id: item.id,
                    homey: this.homey,
                    manager: this,
                    properties: { ...item },
                  });

                  if (this.isConnected()) {
                    this.__cache[itemId][item.id] = item;
                  }

                  return item;
                }
                case 'getAll': {
                  const items = {};

                  // Add all to cache
                  for (let item of Object.values(result)) {
                    item = Item.transformGet(item);

                    if (this.isConnected() && this.__cache[itemId][item.id]) {
                      items[item.id] = this.__cache[itemId][item.id];
                      items[item.id].__update(item);
                    } else {
                      items[item.id] = new Item({
                        id: item.id,
                        homey: this.homey,
                        manager: this,
                        properties: { ...item },
                      });

                      if (this.isConnected()) {
                        this.__cache[itemId][item.id] = items[item.id];
                      }
                    }
                  }

                  // Find and delete deleted items from cache
                  if (this.__cache[itemId]) {
                    for (const cachedItem of Object.values(this.__cache[itemId])) {
                      if (!items[cachedItem.id]) {
                        delete this.__cache[itemId][cachedItem.id];
                      }
                    }
                  }

                  // Mark cache as complete
                  if (this.isConnected()) {
                    this.__cacheAllComplete[itemId] = true;
                  }

                  return items;
                }
                case 'createOne':
                case 'updateOne': {
                  let item = { ...result };
                  item = Item.transformGet(item);

                  if (this.isConnected() && this.__cache[itemId][item.id]) {
                    item = this.__cache[itemId][item.id];
                    item.__update(item);
                  } else {
                    item = Item.transformGet(item);
                    item = new Item({
                      id: item.id,
                      homey: this.homey,
                      manager: this,
                      properties: { ...item },
                    });

                    if (this.isConnected()) {
                      this.__cache[itemId][item.id] = item;
                    }
                  }

                  return item;
                }
                case 'deleteOne': {
                  if (this.isConnected() && this.__cache[itemId][args.id]) {
                    this.__cache[itemId][args.id].destroy();
                    delete this.__cache[itemId][args.id];
                  }

                  return undefined;
                }
                default:
                  break;
              }
            }

            this.__debug(`${operationId} took ${benchmark()}ms`);
            return result;
          },
        });
    }
  }

  get uri() {
    return `homey:manager:${this.constructor.ID}`;
  }

  __debug(...props) {
    this.homey.__debug(`[${this.constructor.name}]`, ...props);
  }

  /**
   * If this manager's namespace is connected to Socket.io.
   * @returns {Boolean}
   */
  isConnected() {
    return this.__connected === true;
  }

  /**
   * Connect to the realtime namespace.
   * @returns {Promise<void>}
   */
  async connect() {
    this.__debug('connect');

    // If disconnecting, await that first
    try {
      await this.__disconnectPromise;
    } catch (err) { }

    this.__connectPromise = Promise.resolve().then(async () => {
      if (!this.io) {
        this.io = this.homey.subscribe(this.uri, {
          onConnect: () => {
            this.__debug('onConnect');
            this.__connected = true;
          },
          onDisconnect: reason => {
            this.__debug(`onDisconnect Reason:${reason}`);
            this.__connected = false;

            // Clear CRUD Item cache
            for (const itemId of Object.keys(this.__cache)) {
              this.__cache[itemId] = {};
              this.__cacheAllComplete[itemId] = false;
            }
          },
          onEvent: (event, data) => {
            this.__debug('onEvent', event);

            // Transform & add to cache if this is a CRUD event
            if (event.endsWith('.create')
              || event.endsWith('.update')
              || event.endsWith('.delete')) {
              const [itemId, operation] = event.split('.');
              const Item = this.items[itemId];

              switch (operation) {
                case 'create': {
                  data = Item.transformGet(data);

                  const item = new Item({
                    id: data.id,
                    homey: this.homey,
                    manager: this,
                    properties: { ...data },
                  });
                  this.__cache[itemId][data.id] = item;

                  return this.emit(event, item);
                }
                case 'update': {
                  data = Item.transformGet(data);

                  if (this.__cache[itemId][data.id]) {
                    const item = this.__cache[itemId][data.id];
                    item.__update(data);
                    return this.emit(event, item);
                  }

                  break;
                }
                case 'delete': {
                  data = Item.transformGet(data);

                  if (this.__cache[itemId][data.id]) {
                    const item = this.__cache[itemId][data.id];
                    item.__delete();
                    delete this.__cache[itemId][item.id];
                    return this.emit(event, {
                      id: item.id,
                    });
                  }

                  break;
                }
                default:
                  break;
              }
            }

            // Fire event listeners
            this.emit(event, data);
          },
        });
      }

      await this.io;
    });

    // Delete the connecting Promise
    this.__connectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__connectPromise;
      });

    await this.__connectPromise;
  }

  /**
   * Disconnect from the realtime namespace.
   * @returns {Promise<void>}
   */
  async disconnect() {
    this.__debug('disconnect');

    // If connecting, await that first
    try {
      await this.__connectPromise;
    } catch (err) { }

    this.__disconnectPromise = Promise.resolve().then(async () => {
      this.__connected = false;

      if (this.io) {
        await this.io
          .then(io => io.unsubscribe())
          .catch(err => this.__debug('Error Disconnecting:', err));

        delete this.io;
      }
    });

    // Delete the disconnecting Promise
    this.__disconnectPromise
      .catch(() => { })
      .finally(() => {
        delete this.__disconnectPromise;
      });

    await this.__disconnectPromise;
  }

  destroy() {
    // Clear cache
    for (const id of Object.keys(this.__cache)) {
      this.__cache[id] = {};
    }

    for (const id of Object.keys(this.__cacheAllComplete)) {
      this.__cacheAllComplete[id] = false;
    }

    // Remove all event listeners
    this.removeAllListeners();

    // Disconnect from Socket.io
    this.disconnect().catch(() => { });
  }

}

module.exports = Manager;
